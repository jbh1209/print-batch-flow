[
  {
    "schema": "public",
    "function_name": "notify_scheduler_when_proof_completed",
    "definition": "CREATE OR REPLACE FUNCTION public.notify_scheduler_when_proof_completed()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  is_proof boolean;\r\nbegin\r\n  if tg_op = 'UPDATE'\r\n     and NEW.status is distinct from OLD.status\r\n     and NEW.status = 'completed'\r\n  then\r\n    -- is this the PROOF stage?\r\n    select exists (\r\n      select 1\r\n      from public.production_stages ps\r\n      where ps.id = NEW.production_stage_id\r\n        and ps.name ilike 'PROOF'\r\n    ) into is_proof;\r\n\r\n    if is_proof then\r\n      perform public._schedule_job_via_edge(NEW.job_id, 'proof_completed_jsi');\r\n    end if;\r\n  end if;\r\n\r\n  return NEW;\r\nend\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "trigger_schedule_on_proof_approval",
    "definition": "CREATE OR REPLACE FUNCTION public.trigger_schedule_on_proof_approval()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\ndeclare\n  is_proof boolean;\n  req_id uuid;\nbegin\n  -- Only when proof approved transitions from NULL to NOT NULL\n  if new.proof_approved_manually_at is not null and (old.proof_approved_manually_at is null) then\n    -- Check this stage is a Proof stage by name\n    select ps.name ilike '%proof%' into is_proof\n    from public.production_stages ps\n    where ps.id = new.production_stage_id;\n\n    if coalesce(is_proof, false) then\n      -- Fire-and-forget call to edge function (public function, handles auth internally)\n      select net.http_post(\n        url := 'https://kgizusgqexmlfcqfjopk.supabase.co/functions/v1/schedule-on-approval',\n        headers := '{\"Content-Type\": \"application/json\"}'::jsonb,\n        body := jsonb_build_object('job_id', new.job_id, 'job_table_name', new.job_table_name)\n      ) into req_id;\n    end if;\n  end if;\n  return new;\nend;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "_schedule_job_via_edge",
    "definition": "CREATE OR REPLACE FUNCTION public._schedule_job_via_edge(p_job_id uuid, p_event text DEFAULT 'auto'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n  v_first_stage uuid;\r\n  v_base_start  timestamptz;\r\n  v_req         jsonb;\r\n  v_resp        jsonb;\r\n  v_fn_url      text := 'https://kgizusgqexmlfcqfjopk.functions.supabase.co/scheduler-run';\r\n  v_anon        text := 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtnaXp1c2dxZXhtbGZjcWZqb3BrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ1NTQwNzAsImV4cCI6MjA2MDEzMDA3MH0.NA2wRme-L8Z15my7n8u-BCQtO4Nw2opfsX0KSLYcs-I';\r\nBEGIN\r\n  -- First pending/queued stage for this job (if none, job is fully done)\r\n  SELECT jsi.production_stage_id\r\n    INTO v_first_stage\r\n  FROM public.job_stage_instances jsi\r\n  WHERE jsi.job_id = p_job_id\r\n    AND COALESCE(jsi.status,'pending') IN ('pending','queued')\r\n  ORDER BY COALESCE(jsi.stage_order,9999), jsi.created_at\r\n  LIMIT 1;\r\n\r\n  -- If the job has no pending stages, just return\r\n  IF v_first_stage IS NULL THEN\r\n    v_resp := jsonb_build_object('ok', true, 'note','no pending stages');\r\n    RETURN v_resp;\r\n  END IF;\r\n\r\n  -- Append after that stage's queue (or use now() if empty)\r\n  SELECT GREATEST(COALESCE(MAX(sts.slot_end_time), NOW()), NOW())\r\n    INTO v_base_start\r\n  FROM public.stage_time_slots sts\r\n  WHERE sts.production_stage_id = v_first_stage;\r\n\r\n  -- Build POST body (force append by giving baseStart)\r\n  v_req := jsonb_build_object(\r\n    'commit',        true,\r\n    'proposed',      false,\r\n    'onlyIfUnset',   true,\r\n    'nuclear',       false,\r\n    'onlyJobIds',    jsonb_build_array(p_job_id),\r\n    'baseStart',     to_char(v_base_start AT TIME ZONE 'UTC', 'YYYY-MM-DD\"T\"HH24:MI:SS\"Z\"')\r\n  );\r\n\r\n  -- Call the Edge function\r\n  SELECT net.http_post(\r\n           url := v_fn_url,\r\n           headers := jsonb_build_object(\r\n             'Content-Type','application/json',\r\n             'Authorization','Bearer '||v_anon\r\n           ),\r\n           body := v_req,\r\n           timeout_milliseconds := 6000\r\n         )\r\n    INTO v_resp;\r\n\r\n  -- Log to scheduler_webhook_log (request_body is jsonb in your schema)\r\n  INSERT INTO public.scheduler_webhook_log(\r\n    created_at, event, job_id, order_no,\r\n    request_id, http_status, response_excerpt, http_error, request_body\r\n  )\r\n  SELECT\r\n    NOW(), COALESCE(p_event,'auto'), pj.id, pj.wo_no,\r\n    NULL,\r\n    COALESCE((v_resp->'response'->>'status_code')::int, 0),\r\n    LEFT(COALESCE(v_resp->'response'->>'body',''), 4000),\r\n    '',\r\n    v_req\r\n  FROM public.production_jobs pj\r\n  WHERE pj.id = p_job_id;\r\n\r\n  RETURN v_resp;\r\nEND $function$\n"
  },
  {
    "schema": "public",
    "function_name": "notify_scheduler_on_proof_approval",
    "definition": "CREATE OR REPLACE FUNCTION public.notify_scheduler_on_proof_approval()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  v_fn_url    text := 'https://kgizusgqexmlfcqfjopk.functions.supabase.co/scheduler-run';\r\n  v_anon      text := 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtnaXp1c2dxZXhtbGZjcWZqb3BrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ1NTQwNzAsImV4cCI6MjA2MDEzMDA3MH0.NA2wRme-L8Z15my7n8u-BCQtO4Nw2opfsX0KSLYcs-I';\r\n  v_body      jsonb;\r\n  v_req_id    bigint;\r\n  v_http      int := 0;\r\n  v_resp_txt  text := '';\r\n  v_status    text := '';\r\nbegin\r\n  -- fire only when proof_approved_at flips from NULL to non-NULL (or changes)\r\n  if tg_op = 'UPDATE'\r\n     and NEW.proof_approved_at is not null\r\n     and (OLD.proof_approved_at is null or NEW.proof_approved_at <> OLD.proof_approved_at)\r\n  then\r\n    -- payload for Edge Function\r\n    v_body := jsonb_build_object(\r\n      'commit', true,\r\n      'proposed', false,\r\n      'onlyIfUnset', false,           -- <- force schedule even if minutes are 0\r\n      'nuclear', false,\r\n      'onlyJobIds', jsonb_build_array(NEW.id)\r\n    );\r\n\r\n    -- call the function (returns request_id)\r\n    select net.http_post(\r\n             url := v_fn_url,\r\n             headers := jsonb_build_object(\r\n               'Content-Type','application/json',\r\n               'Authorization','Bearer ' || v_anon\r\n             ),\r\n             body := v_body,\r\n             timeout_milliseconds := 8000\r\n           )\r\n      into v_req_id;\r\n\r\n    -- write initial log row\r\n    insert into public.scheduler_webhook_log(\r\n      created_at, job_id, order_no, event,\r\n      request_id, request_body, http_status, response_excerpt, http_error\r\n    )\r\n    values (\r\n      now(), NEW.id, NEW.wo_no, 'proof_approved',\r\n      v_req_id, v_body, 0, '', ''\r\n    );\r\n\r\n    -- collect the HTTP response using the older, working collector\r\n    begin\r\n      select r.status,\r\n             coalesce((r.response).status_code, 0),\r\n             coalesce((r.response).body, '')\r\n        into  v_status, v_http, v_resp_txt\r\n      from net._http_collect_response(v_req_id) as r;\r\n\r\n    exception when others then\r\n      -- if even the fallback blew up, just record the error text\r\n      v_status := SQLERRM;\r\n      v_http   := 0;\r\n      v_resp_txt := '';\r\n    end;\r\n\r\n    update public.scheduler_webhook_log\r\n       set http_status      = v_http,\r\n           response_excerpt = left(coalesce(v_resp_txt,''), 4000),\r\n           http_error       = case when v_http between 200 and 299 then '' else coalesce(v_status,'') end\r\n     where request_id = v_req_id;\r\n  end if;\r\n\r\n  return NEW;\r\nend\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "trigger_simple_scheduler",
    "definition": "CREATE OR REPLACE FUNCTION public.trigger_simple_scheduler()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Only trigger when status changes to something that indicates approval\n  -- Common approval statuses: 'approved', 'ready', 'in production', etc.\n  IF NEW.status IS DISTINCT FROM OLD.status AND \n     (NEW.status ILIKE '%approved%' OR \n      NEW.status ILIKE '%ready%' OR \n      NEW.status ILIKE '%production%' OR\n      NEW.status = 'Pre-Press') THEN\n    \n    -- Call the simple scheduler edge function\n    PERFORM net.http_post(\n      url := 'https://kgizusgqexmlfcqfjopk.supabase.co/functions/v1/simple-scheduler',\n      headers := '{\"Content-Type\": \"application/json\", \"Authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtnaXp1c2dxZXhtbGZjcWZqb3BrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ1NTQwNzAsImV4cCI6MjA2MDEzMDA3MH0.NA2wRme-L8Z15my7n8u-BCQtO4Nw2opfsX0KSLYcs-I\"}'::jsonb,\n      body := jsonb_build_object(\n        'job_id', NEW.id,\n        'job_table_name', 'production_jobs'\n      )\n    );\n    \n    RAISE NOTICE 'Triggered simple scheduler for job % with status %', NEW.id, NEW.status;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  }
]