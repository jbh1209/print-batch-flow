[
  {
    "function_schema": "auth",
    "function_name": "email",
    "args": "",
    "language": "sql",
    "security_definer": false,
    "volatility": "s",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION auth.email()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n$function$\n"
  },
  {
    "function_schema": "auth",
    "function_name": "jwt",
    "args": "",
    "language": "sql",
    "security_definer": false,
    "volatility": "s",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION auth.jwt()\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n$function$\n"
  },
  {
    "function_schema": "auth",
    "function_name": "role",
    "args": "",
    "language": "sql",
    "security_definer": false,
    "volatility": "s",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION auth.role()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n$function$\n"
  },
  {
    "function_schema": "auth",
    "function_name": "uid",
    "args": "",
    "language": "sql",
    "security_definer": false,
    "volatility": "s",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION auth.uid()\n RETURNS uuid\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.sub', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')\n  )::uuid\n$function$\n"
  },
  {
    "function_schema": "cron",
    "function_name": "alter_job",
    "args": "job_id bigint, schedule text, command text, database text, username text, active boolean",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION cron.alter_job(job_id bigint, schedule text DEFAULT NULL::text, command text DEFAULT NULL::text, database text DEFAULT NULL::text, username text DEFAULT NULL::text, active boolean DEFAULT NULL::boolean)\n RETURNS void\n LANGUAGE c\nAS '$libdir/pg_cron', $function$cron_alter_job$function$\n"
  },
  {
    "function_schema": "cron",
    "function_name": "job_cache_invalidate",
    "args": "",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION cron.job_cache_invalidate()\n RETURNS trigger\n LANGUAGE c\nAS '$libdir/pg_cron', $function$cron_job_cache_invalidate$function$\n"
  },
  {
    "function_schema": "cron",
    "function_name": "schedule",
    "args": "job_name text, schedule text, command text",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION cron.schedule(job_name text, schedule text, command text)\n RETURNS bigint\n LANGUAGE c\nAS '$libdir/pg_cron', $function$cron_schedule_named$function$\n"
  },
  {
    "function_schema": "cron",
    "function_name": "schedule",
    "args": "schedule text, command text",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION cron.schedule(schedule text, command text)\n RETURNS bigint\n LANGUAGE c\n STRICT\nAS '$libdir/pg_cron', $function$cron_schedule$function$\n"
  },
  {
    "function_schema": "cron",
    "function_name": "schedule_in_database",
    "args": "job_name text, schedule text, command text, database text, username text, active boolean",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION cron.schedule_in_database(job_name text, schedule text, command text, database text, username text DEFAULT NULL::text, active boolean DEFAULT true)\n RETURNS bigint\n LANGUAGE c\nAS '$libdir/pg_cron', $function$cron_schedule_named$function$\n"
  },
  {
    "function_schema": "cron",
    "function_name": "unschedule",
    "args": "job_id bigint",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION cron.unschedule(job_id bigint)\n RETURNS boolean\n LANGUAGE c\n STRICT\nAS '$libdir/pg_cron', $function$cron_unschedule$function$\n"
  },
  {
    "function_schema": "cron",
    "function_name": "unschedule",
    "args": "job_name text",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION cron.unschedule(job_name text)\n RETURNS boolean\n LANGUAGE c\n STRICT\nAS '$libdir/pg_cron', $function$cron_unschedule_named$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "algorithm_sign",
    "args": "signables text, secret text, algorithm text",
    "language": "sql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.algorithm_sign(signables text, secret text, algorithm text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH\n  alg AS (\n    SELECT CASE\n      WHEN algorithm = 'HS256' THEN 'sha256'\n      WHEN algorithm = 'HS384' THEN 'sha384'\n      WHEN algorithm = 'HS512' THEN 'sha512'\n      ELSE '' END AS id)  -- hmac throws error\nSELECT extensions.url_encode(extensions.hmac(signables, secret, alg.id)) FROM alg;\n$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "armor",
    "args": "bytea",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.armor(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "armor",
    "args": "bytea, text[], text[]",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "crypt",
    "args": "text, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.crypt(text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_crypt$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "dearmor",
    "args": "text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.dearmor(text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_dearmor$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "decrypt",
    "args": "bytea, bytea, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "decrypt_iv",
    "args": "bytea, bytea, bytea, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "digest",
    "args": "bytea, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.digest(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "digest",
    "args": "text, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.digest(text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "encrypt",
    "args": "bytea, bytea, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "encrypt_iv",
    "args": "bytea, bytea, bytea, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "gen_random_bytes",
    "args": "integer",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_random_bytes$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "gen_random_uuid",
    "args": "",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.gen_random_uuid()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/pgcrypto', $function$pg_random_uuid$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "gen_salt",
    "args": "text",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "gen_salt",
    "args": "text, integer",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "grant_pg_cron_access",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_cron'\n  )\n  THEN\n    grant usage on schema cron to postgres with grant option;\n\n    alter default privileges in schema cron grant all on tables to postgres with grant option;\n    alter default privileges in schema cron grant all on functions to postgres with grant option;\n    alter default privileges in schema cron grant all on sequences to postgres with grant option;\n\n    alter default privileges for user supabase_admin in schema cron grant all\n        on sequences to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on tables to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on functions to postgres with grant option;\n\n    grant all privileges on all tables in schema cron to postgres with grant option;\n    revoke all on table cron.job from postgres;\n    grant select on table cron.job to postgres with grant option;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "grant_pg_graphql_access",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    func_is_graphql_resolve bool;\nBEGIN\n    func_is_graphql_resolve = (\n        SELECT n.proname = 'resolve'\n        FROM pg_event_trigger_ddl_commands() AS ev\n        LEFT JOIN pg_catalog.pg_proc AS n\n        ON ev.objid = n.oid\n    );\n\n    IF func_is_graphql_resolve\n    THEN\n        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func\n        DROP FUNCTION IF EXISTS graphql_public.graphql;\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language sql\n        as $$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $$;\n\n        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last\n        -- function in the extension so we need to grant permissions on existing entities AND\n        -- update default permissions to any others that are created after `graphql.resolve`\n        grant usage on schema graphql to postgres, anon, authenticated, service_role;\n        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;\n        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;\n        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;\n\n        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles\n        grant usage on schema graphql_public to postgres with grant option;\n        grant usage on schema graphql to postgres with grant option;\n    END IF;\n\nEND;\n$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "grant_pg_net_access",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_net'\n  )\n  THEN\n    IF NOT EXISTS (\n      SELECT 1\n      FROM pg_roles\n      WHERE rolname = 'supabase_functions_admin'\n    )\n    THEN\n      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;\n    END IF;\n\n    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n\n    IF EXISTS (\n      SELECT FROM pg_extension\n      WHERE extname = 'pg_net'\n      -- all versions in use on existing projects as of 2025-02-20\n      -- version 0.12.0 onwards don't need these applied\n      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')\n    ) THEN\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n\n      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n\n      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n    END IF;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "hmac",
    "args": "bytea, bytea, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "hmac",
    "args": "text, text, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pg_stat_statements",
    "args": "showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision)\n RETURNS SETOF record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_1_10$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pg_stat_statements_info",
    "args": "OUT dealloc bigint, OUT stats_reset timestamp with time zone",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)\n RETURNS record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_info$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pg_stat_statements_reset",
    "args": "userid oid, dbid oid, queryid bigint",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0)\n RETURNS void\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_reset_1_7$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_armor_headers",
    "args": "text, OUT key text, OUT value text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)\n RETURNS SETOF record\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_armor_headers$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_key_id",
    "args": "bytea",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_key_id_w$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_pub_decrypt",
    "args": "bytea, bytea",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_pub_decrypt",
    "args": "bytea, bytea, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_pub_decrypt",
    "args": "bytea, bytea, text, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "args": "bytea, bytea",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "args": "bytea, bytea, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "args": "bytea, bytea, text, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_pub_encrypt",
    "args": "text, bytea",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_pub_encrypt",
    "args": "text, bytea, text",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_pub_encrypt_bytea",
    "args": "bytea, bytea",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_pub_encrypt_bytea",
    "args": "bytea, bytea, text",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_sym_decrypt",
    "args": "bytea, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_sym_decrypt",
    "args": "bytea, text, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_sym_decrypt_bytea",
    "args": "bytea, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_sym_decrypt_bytea",
    "args": "bytea, text, text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_sym_encrypt",
    "args": "text, text",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_sym_encrypt",
    "args": "text, text, text",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_sym_encrypt_bytea",
    "args": "bytea, text",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgp_sym_encrypt_bytea",
    "args": "bytea, text, text",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgrst_ddl_watch",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  cmd record;\nBEGIN\n  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()\n  LOOP\n    IF cmd.command_tag IN (\n      'CREATE SCHEMA', 'ALTER SCHEMA'\n    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'\n    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'\n    , 'CREATE VIEW', 'ALTER VIEW'\n    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'\n    , 'CREATE FUNCTION', 'ALTER FUNCTION'\n    , 'CREATE TRIGGER'\n    , 'CREATE TYPE', 'ALTER TYPE'\n    , 'CREATE RULE'\n    , 'COMMENT'\n    )\n    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp\n    AND cmd.schema_name is distinct from 'pg_temp'\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "pgrst_drop_watch",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  obj record;\nBEGIN\n  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n  LOOP\n    IF obj.object_type IN (\n      'schema'\n    , 'table'\n    , 'foreign table'\n    , 'view'\n    , 'materialized view'\n    , 'function'\n    , 'trigger'\n    , 'type'\n    , 'rule'\n    )\n    AND obj.is_temporary IS false -- no pg_temp objects\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "set_graphql_placeholder",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\n    DECLARE\n    graphql_is_dropped bool;\n    BEGIN\n    graphql_is_dropped = (\n        SELECT ev.schema_name = 'graphql_public'\n        FROM pg_event_trigger_dropped_objects() AS ev\n        WHERE ev.schema_name = 'graphql_public'\n    );\n\n    IF graphql_is_dropped\n    THEN\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language plpgsql\n        as $$\n            DECLARE\n                server_version float;\n            BEGIN\n                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);\n\n                IF server_version >= 14 THEN\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql extension is not enabled.'\n                            )\n                        )\n                    );\n                ELSE\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'\n                            )\n                        )\n                    );\n                END IF;\n            END;\n        $$;\n    END IF;\n\n    END;\n$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "sign",
    "args": "payload json, secret text, algorithm text",
    "language": "sql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.sign(payload json, secret text, algorithm text DEFAULT 'HS256'::text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH\n  header AS (\n    SELECT extensions.url_encode(convert_to('{\"alg\":\"' || algorithm || '\",\"typ\":\"JWT\"}', 'utf8')) AS data\n    ),\n  payload AS (\n    SELECT extensions.url_encode(convert_to(payload::text, 'utf8')) AS data\n    ),\n  signables AS (\n    SELECT header.data || '.' || payload.data AS data FROM header, payload\n    )\nSELECT\n    signables.data || '.' ||\n    extensions.algorithm_sign(signables.data, secret, algorithm) FROM signables;\n$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "try_cast_double",
    "args": "inp text",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.try_cast_double(inp text)\n RETURNS double precision\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n  BEGIN\n    BEGIN\n      RETURN inp::double precision;\n    EXCEPTION\n      WHEN OTHERS THEN RETURN NULL;\n    END;\n  END;\n$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "url_decode",
    "args": "data text",
    "language": "sql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.url_decode(data text)\n RETURNS bytea\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH t AS (SELECT translate(data, '-_', '+/') AS trans),\n     rem AS (SELECT length(t.trans) % 4 AS remainder FROM t) -- compute padding size\n    SELECT decode(\n        t.trans ||\n        CASE WHEN rem.remainder > 0\n           THEN repeat('=', (4 - rem.remainder))\n           ELSE '' END,\n    'base64') FROM t, rem;\n$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "url_encode",
    "args": "data bytea",
    "language": "sql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.url_encode(data bytea)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    SELECT translate(encode(data, 'base64'), E'+/=\\n', '-_');\n$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "uuid_generate_v1",
    "args": "",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "uuid_generate_v1mc",
    "args": "",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "uuid_generate_v3",
    "args": "namespace uuid, name text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "uuid_generate_v4",
    "args": "",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "uuid_generate_v5",
    "args": "namespace uuid, name text",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "uuid_nil",
    "args": "",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.uuid_nil()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_nil$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "uuid_ns_dns",
    "args": "",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "uuid_ns_oid",
    "args": "",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "uuid_ns_url",
    "args": "",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_url()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_url$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "uuid_ns_x500",
    "args": "",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$\n"
  },
  {
    "function_schema": "extensions",
    "function_name": "verify",
    "args": "token text, secret text, algorithm text",
    "language": "sql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION extensions.verify(token text, secret text, algorithm text DEFAULT 'HS256'::text)\n RETURNS TABLE(header json, payload json, valid boolean)\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n  SELECT\n    jwt.header AS header,\n    jwt.payload AS payload,\n    jwt.signature_ok AND tstzrange(\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'nbf')),\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'exp'))\n    ) @> CURRENT_TIMESTAMP AS valid\n  FROM (\n    SELECT\n      convert_from(extensions.url_decode(r[1]), 'utf8')::json AS header,\n      convert_from(extensions.url_decode(r[2]), 'utf8')::json AS payload,\n      r[3] = extensions.algorithm_sign(r[1] || '.' || r[2], secret, algorithm) AS signature_ok\n    FROM regexp_split_to_array(token, '\\.') r\n  ) jwt\n$function$\n"
  },
  {
    "function_schema": "graphql",
    "function_name": "_internal_resolve",
    "args": "query text, variables jsonb, \"operationName\" text, extensions jsonb",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION graphql._internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE c\nAS '$libdir/pg_graphql', $function$resolve_wrapper$function$\n"
  },
  {
    "function_schema": "graphql",
    "function_name": "comment_directive",
    "args": "comment_ text",
    "language": "sql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION graphql.comment_directive(comment_ text)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    comment on column public.account.name is '@graphql.name: myField'\n    */\n    select\n        coalesce(\n            (\n                regexp_match(\n                    comment_,\n                    '@graphql\\((.+)\\)'\n                )\n            )[1]::jsonb,\n            jsonb_build_object()\n        )\n$function$\n"
  },
  {
    "function_schema": "graphql",
    "function_name": "exception",
    "args": "message text",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION graphql.exception(message text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nbegin\n    raise exception using errcode='22000', message=message;\nend;\n$function$\n"
  },
  {
    "function_schema": "graphql",
    "function_name": "get_schema_version",
    "args": "",
    "language": "sql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION graphql.get_schema_version()\n RETURNS integer\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n    select last_value from graphql.seq_schema_version;\n$function$\n"
  },
  {
    "function_schema": "graphql",
    "function_name": "increment_schema_version",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION graphql.increment_schema_version()\n RETURNS event_trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n    perform pg_catalog.nextval('graphql.seq_schema_version');\nend;\n$function$\n"
  },
  {
    "function_schema": "graphql",
    "function_name": "resolve",
    "args": "query text, variables jsonb, \"operationName\" text, extensions jsonb",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION graphql.resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    res jsonb;\n    message_text text;\nbegin\n  begin\n    select graphql._internal_resolve(\"query\" := \"query\",\n                                     \"variables\" := \"variables\",\n                                     \"operationName\" := \"operationName\",\n                                     \"extensions\" := \"extensions\") into res;\n    return res;\n  exception\n    when others then\n    get stacked diagnostics message_text = message_text;\n    return\n    jsonb_build_object('data', null,\n                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));\n  end;\nend;\n$function$\n"
  },
  {
    "function_schema": "graphql_public",
    "function_name": "graphql",
    "args": "\"operationName\" text, query text, variables jsonb, extensions jsonb",
    "language": "sql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION graphql_public.graphql(\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE sql\nAS $function$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $function$\n"
  },
  {
    "function_schema": "net",
    "function_name": "_await_response",
    "args": "request_id bigint",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION net._await_response(request_id bigint)\n RETURNS boolean\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\ndeclare\n    rec net._http_response;\nbegin\n    while rec is null loop\n        select *\n        into rec\n        from net._http_response\n        where id = request_id;\n\n        if rec is null then\n            -- Wait 50 ms before checking again\n            perform pg_sleep(0.05);\n        end if;\n    end loop;\n\n    return true;\nend;\n$function$\n"
  },
  {
    "function_schema": "net",
    "function_name": "_encode_url_with_params_array",
    "args": "url text, params_array text[]",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION net._encode_url_with_params_array(url text, params_array text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS 'pg_net', $function$_encode_url_with_params_array$function$\n"
  },
  {
    "function_schema": "net",
    "function_name": "_http_collect_response",
    "args": "request_id bigint, async boolean",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION net._http_collect_response(request_id bigint, async boolean DEFAULT true)\n RETURNS net.http_response_result\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\ndeclare\n    rec net._http_response;\n    req_exists boolean;\nbegin\n\n    if not async then\n        perform net._await_response(request_id);\n    end if;\n\n    select *\n    into rec\n    from net._http_response\n    where id = request_id;\n\n    if rec is null or rec.error_msg is not null then\n        -- The request is either still processing or the request_id provided does not exist\n\n        -- TODO: request in progress is indistinguishable from request that doesn't exist\n\n        -- No request matching request_id found\n        return (\n            'ERROR',\n            coalesce(rec.error_msg, 'request matching request_id not found'),\n            null\n        )::net.http_response_result;\n\n    end if;\n\n    -- Return a valid, populated http_response_result\n    return (\n        'SUCCESS',\n        'ok',\n        (\n            rec.status_code,\n            rec.headers,\n            rec.content\n        )::net.http_response\n    )::net.http_response_result;\nend;\n$function$\n"
  },
  {
    "function_schema": "net",
    "function_name": "_urlencode_string",
    "args": "string character varying",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION net._urlencode_string(string character varying)\n RETURNS text\n LANGUAGE c\n IMMUTABLE STRICT\nAS 'pg_net', $function$_urlencode_string$function$\n"
  },
  {
    "function_schema": "net",
    "function_name": "check_worker_is_up",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION net.check_worker_is_up()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nbegin\n  if not exists (select pid from pg_stat_activity where backend_type ilike '%pg_net%') then\n    raise exception using\n      message = 'the pg_net background worker is not up'\n    , detail  = 'the pg_net background worker is down due to an internal error and cannot process requests'\n    , hint    = 'make sure that you didn''t modify any of pg_net internal tables';\n  end if;\nend\n$function$\n"
  },
  {
    "function_schema": "net",
    "function_name": "http_collect_response",
    "args": "request_id bigint, async boolean",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION net.http_collect_response(request_id bigint, async boolean DEFAULT true)\n RETURNS net.http_response_result\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\nbegin\n  raise notice 'The net.http_collect_response function is deprecated.';\n  select net._http_collect_response(request_id, async);\nend;\n$function$\n"
  },
  {
    "function_schema": "net",
    "function_name": "http_delete",
    "args": "url text, params jsonb, headers jsonb, timeout_milliseconds integer",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION net.http_delete(url text, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{}'::jsonb, timeout_milliseconds integer DEFAULT 5000)\n RETURNS bigint\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\nAS $function$\ndeclare\n    request_id bigint;\n    params_array text[];\nbegin\n    select coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into params_array\n    from jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, timeout_milliseconds)\n    values (\n        'DELETE',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n$function$\n"
  },
  {
    "function_schema": "net",
    "function_name": "http_get",
    "args": "url text, params jsonb, headers jsonb, timeout_milliseconds integer",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION net.http_get(url text, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{}'::jsonb, timeout_milliseconds integer DEFAULT 5000)\n RETURNS bigint\n LANGUAGE plpgsql\n PARALLEL SAFE STRICT\n SET search_path TO 'net'\nAS $function$\ndeclare\n    request_id bigint;\n    params_array text[];\nbegin\n    select coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into params_array\n    from jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, timeout_milliseconds)\n    values (\n        'GET',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n$function$\n"
  },
  {
    "function_schema": "net",
    "function_name": "http_post",
    "args": "url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION net.http_post(url text, body jsonb DEFAULT '{}'::jsonb, params jsonb DEFAULT '{}'::jsonb, headers jsonb DEFAULT '{\"Content-Type\": \"application/json\"}'::jsonb, timeout_milliseconds integer DEFAULT 5000)\n RETURNS bigint\n LANGUAGE plpgsql\n PARALLEL SAFE\n SET search_path TO 'net'\nAS $function$\ndeclare\n    request_id bigint;\n    params_array text[];\n    content_type text;\nbegin\n\n    -- Exctract the content_type from headers\n    select\n        header_value into content_type\n    from\n        jsonb_each_text(coalesce(headers, '{}'::jsonb)) r(header_name, header_value)\n    where\n        lower(header_name) = 'content-type'\n    limit\n        1;\n\n    -- If the user provided new headers and omitted the content type\n    -- add it back in automatically\n    if content_type is null then\n        select headers || '{\"Content-Type\": \"application/json\"}'::jsonb into headers;\n    end if;\n\n    -- Confirm that the content-type is set as \"application/json\"\n    if content_type <> 'application/json' then\n        raise exception 'Content-Type header must be \"application/json\"';\n    end if;\n\n    select\n        coalesce(array_agg(net._urlencode_string(key) || '=' || net._urlencode_string(value)), '{}')\n    into\n        params_array\n    from\n        jsonb_each_text(params);\n\n    -- Add to the request queue\n    insert into net.http_request_queue(method, url, headers, body, timeout_milliseconds)\n    values (\n        'POST',\n        net._encode_url_with_params_array(url, params_array),\n        headers,\n        convert_to(body::text, 'UTF8'),\n        timeout_milliseconds\n    )\n    returning id\n    into request_id;\n\n    return request_id;\nend\n$function$\n"
  },
  {
    "function_schema": "net",
    "function_name": "worker_restart",
    "args": "",
    "language": "c",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION net.worker_restart()\n RETURNS boolean\n LANGUAGE c\nAS 'pg_net', $function$worker_restart$function$\n"
  },
  {
    "function_schema": "pgbouncer",
    "function_name": "get_auth",
    "args": "p_usename text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename text)\n RETURNS TABLE(username text, password text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n    raise debug 'PgBouncer auth request: %', p_usename;\n\n    return query\n    select \n        rolname::text, \n        case when rolvaliduntil < now() \n            then null \n            else rolpassword::text \n        end \n    from pg_authid \n    where rolname=$1 and rolcanlogin;\nend;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "_fill_stage_time_slots_date",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public._fill_stage_time_slots_date()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.\"date\" := (NEW.slot_start_time AT TIME ZONE 'UTC')::date;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "_sts_fill_date",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public._sts_fill_date()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  if NEW.\"date\" is null then\r\n    NEW.\"date\" := (NEW.slot_start_time at time zone 'UTC')::date;\r\n  end if;\r\n  return NEW;\r\nend\r\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "activate_batch_allocation_for_job",
    "args": "p_job_id uuid, p_job_table_name text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.activate_batch_allocation_for_job(p_job_id uuid, p_job_table_name text DEFAULT 'production_jobs'::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  batch_allocation_stage_id uuid;\nBEGIN\n  -- Find the Batch Allocation stage\n  SELECT id INTO batch_allocation_stage_id\n  FROM public.production_stages\n  WHERE name = 'Batch Allocation'\n  LIMIT 1;\n  \n  IF batch_allocation_stage_id IS NULL THEN\n    RAISE EXCEPTION 'Batch Allocation stage not found';\n  END IF;\n  \n  -- Activate the Batch Allocation stage\n  UPDATE public.job_stage_instances\n  SET \n    status = 'active',\n    started_at = now(),\n    started_by = auth.uid(),\n    updated_at = now()\n  WHERE job_id = p_job_id\n    AND job_table_name = p_job_table_name\n    AND production_stage_id = batch_allocation_stage_id\n    AND status = 'pending';\n  \n  -- Mark job as ready for batching but preserve original WO number\n  UPDATE public.production_jobs\n  SET \n    batch_ready = true,\n    batch_allocated_at = now(),\n    batch_allocated_by = auth.uid(),\n    status = 'Ready for Batch',\n    updated_at = now()\n  WHERE id = p_job_id;\n  \n  RETURN true;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "add_admin_role",
    "args": "admin_user_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.add_admin_role(admin_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  -- Check if user exists\n  IF NOT EXISTS (SELECT 1 FROM auth.users WHERE id = admin_user_id) THEN\n    RAISE EXCEPTION 'User with ID % does not exist', admin_user_id;\n  END IF;\n  \n  -- Insert or update admin role\n  INSERT INTO public.user_roles (user_id, role)\n  VALUES (admin_user_id, 'admin')\n  ON CONFLICT (user_id) \n  DO UPDATE SET role = 'admin', updated_at = now();\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "advance_job_stage",
    "args": "p_job_id uuid, p_job_table_name text, p_current_stage_id uuid, p_completed_by uuid, p_notes text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.advance_job_stage(p_job_id uuid, p_job_table_name text, p_current_stage_id uuid, p_completed_by uuid DEFAULT auth.uid(), p_notes text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  next_concurrent_group_id UUID;\n  is_expedited BOOLEAN := false;\nBEGIN\n  -- Complete current stage\n  UPDATE public.job_stage_instances\n  SET \n    status = 'completed',\n    completed_at = now(),\n    completed_by = p_completed_by,\n    notes = COALESCE(p_notes, notes),\n    updated_at = now()\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND production_stage_id = p_current_stage_id\n    AND status = 'active';\n\n  -- Check if job is expedited\n  IF p_job_table_name = 'production_jobs' THEN\n    SELECT pj.is_expedited INTO is_expedited\n    FROM public.production_jobs pj\n    WHERE pj.id = p_job_id;\n  END IF;\n\n  -- DO NOT auto-activate next stages - leave them pending for operator action\n  -- This was the problem - stages were being auto-activated\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "advance_job_stage",
    "args": "p_job_id uuid, p_job_table_name text, p_current_stage_id uuid, p_notes text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.advance_job_stage(p_job_id uuid, p_job_table_name text, p_current_stage_id uuid, p_notes text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  current_stage_record RECORD;\n  next_stage_record RECORD;\n  actual_duration_minutes INTEGER;\nBEGIN\n  -- Get the current stage instance\n  SELECT * INTO current_stage_record\n  FROM public.job_stage_instances\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND production_stage_id = p_current_stage_id\n    AND status = 'active';\n  \n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Current stage not found or not active';\n  END IF;\n  \n  -- Calculate actual duration if stage was started\n  IF current_stage_record.started_at IS NOT NULL THEN\n    actual_duration_minutes := EXTRACT(EPOCH FROM (now() - current_stage_record.started_at)) / 60;\n  END IF;\n  \n  -- Mark current stage as completed\n  UPDATE public.job_stage_instances\n  SET \n    status = 'completed',\n    completed_at = now(),\n    completed_by = auth.uid(),\n    actual_duration_minutes = actual_duration_minutes,\n    notes = COALESCE(p_notes, notes),\n    updated_at = now()\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND production_stage_id = p_current_stage_id;\n  \n  -- Find and activate the next stage\n  SELECT * INTO next_stage_record\n  FROM public.job_stage_instances\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND stage_order > current_stage_record.stage_order\n    AND status = 'pending'\n  ORDER BY stage_order ASC\n  LIMIT 1;\n  \n  -- If there's a next stage, activate it\n  IF FOUND THEN\n    UPDATE public.job_stage_instances\n    SET \n      status = 'active',\n      started_at = now(),\n      started_by = auth.uid(),\n      updated_at = now()\n    WHERE id = next_stage_record.id;\n  END IF;\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "advance_job_stage_with_groups",
    "args": "p_job_id uuid, p_job_table_name text, p_current_stage_id uuid, p_completed_by uuid, p_notes text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.advance_job_stage_with_groups(p_job_id uuid, p_job_table_name text, p_current_stage_id uuid, p_completed_by uuid DEFAULT auth.uid(), p_notes text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  current_stage_record RECORD;\n  actual_duration_minutes INTEGER;\n  next_stage_record RECORD;\n  current_group_id uuid;\n  parallel_enabled boolean;\nBEGIN\n  -- Get the current stage instance\n  SELECT jsi.*, ps.stage_group_id INTO current_stage_record\n  FROM public.job_stage_instances jsi\n  JOIN public.production_stages ps ON jsi.production_stage_id = ps.id\n  WHERE jsi.job_id = p_job_id \n    AND jsi.job_table_name = p_job_table_name\n    AND jsi.id = p_current_stage_id\n    AND jsi.status = 'active';\n  \n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Current stage not found or not active';\n  END IF;\n  \n  -- Calculate actual duration if stage was started\n  IF current_stage_record.started_at IS NOT NULL THEN\n    actual_duration_minutes := EXTRACT(EPOCH FROM (now() - current_stage_record.started_at)) / 60;\n  END IF;\n  \n  -- Mark current stage as completed\n  UPDATE public.job_stage_instances\n  SET \n    status = 'completed',\n    completed_at = now(),\n    completed_by = p_completed_by,\n    actual_duration_minutes = actual_duration_minutes,\n    notes = COALESCE(p_notes, notes),\n    updated_at = now()\n  WHERE id = p_current_stage_id;\n  \n  -- Get group information for parallel processing logic\n  SELECT sg.id, sg.parallel_processing_enabled INTO current_group_id, parallel_enabled\n  FROM public.stage_groups sg\n  WHERE sg.id = current_stage_record.stage_group_id;\n  \n  -- Check if there are other stages in the same group that can be activated\n  IF parallel_enabled AND current_group_id IS NOT NULL THEN\n    -- Look for other pending stages in the same group and same order\n    FOR next_stage_record IN\n      SELECT jsi.id\n      FROM public.job_stage_instances jsi\n      JOIN public.production_stages ps ON jsi.production_stage_id = ps.id\n      WHERE jsi.job_id = p_job_id \n        AND jsi.job_table_name = p_job_table_name\n        AND jsi.stage_order = current_stage_record.stage_order\n        AND jsi.status = 'pending'\n        AND ps.stage_group_id = current_group_id\n    LOOP\n      -- These stages remain pending - operator must manually start them\n      -- We don't auto-activate anything anymore\n      NULL;\n    END LOOP;\n  END IF;\n  \n  -- Find next sequential stage (different stage_order)\n  SELECT jsi.id INTO next_stage_record\n  FROM public.job_stage_instances jsi\n  WHERE jsi.job_id = p_job_id \n    AND jsi.job_table_name = p_job_table_name\n    AND jsi.stage_order > current_stage_record.stage_order\n    AND jsi.status = 'pending'\n  ORDER BY jsi.stage_order ASC\n  LIMIT 1;\n  \n  -- Next stage remains pending - operator must manually start it\n  -- We don't auto-activate anything anymore\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "advance_job_stage_with_parallel_support",
    "args": "p_job_id uuid, p_job_table_name text, p_current_stage_id uuid, p_notes text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.advance_job_stage_with_parallel_support(p_job_id uuid, p_job_table_name text, p_current_stage_id uuid, p_notes text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  current_stage_record RECORD;\n  next_stage_record RECORD;\n  actual_duration_minutes INTEGER;\nBEGIN\n  -- Get the current stage instance with dependency info\n  SELECT jsi.*, ps.name as stage_name INTO current_stage_record\n  FROM public.job_stage_instances jsi\n  JOIN public.production_stages ps ON jsi.production_stage_id = ps.id\n  WHERE jsi.job_id = p_job_id \n    AND jsi.job_table_name = p_job_table_name\n    AND jsi.production_stage_id = p_current_stage_id\n    AND jsi.status = 'active';\n  \n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Current stage not found or not active';\n  END IF;\n  \n  -- Calculate actual duration if stage was started\n  IF current_stage_record.started_at IS NOT NULL THEN\n    actual_duration_minutes := EXTRACT(EPOCH FROM (now() - current_stage_record.started_at)) / 60;\n  END IF;\n  \n  -- Mark current stage as completed\n  UPDATE public.job_stage_instances\n  SET \n    status = 'completed',\n    completed_at = now(),\n    completed_by = auth.uid(),\n    actual_duration_minutes = actual_duration_minutes,\n    notes = COALESCE(p_notes, notes),\n    updated_at = now()\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND production_stage_id = p_current_stage_id;\n  \n  -- Find and activate all next available stages\n  -- This includes both parallel stages at the same order and sequential stages\n  FOR next_stage_record IN\n    SELECT jsi.id, jsi.dependency_group, jsi.stage_order\n    FROM public.job_stage_instances jsi\n    WHERE jsi.job_id = p_job_id \n      AND jsi.job_table_name = p_job_table_name\n      AND jsi.status = 'pending'\n      AND (\n        -- Parallel stages at same order level (no dependency group or different group)\n        (jsi.stage_order = current_stage_record.stage_order AND \n         (jsi.dependency_group IS NULL OR jsi.dependency_group != current_stage_record.dependency_group))\n        OR\n        -- Next sequential stage (higher order) where dependencies are satisfied\n        (jsi.stage_order > current_stage_record.stage_order AND\n         (jsi.dependency_group IS NULL OR \n          public.check_dependency_completion(p_job_id, p_job_table_name, jsi.dependency_group)))\n      )\n    ORDER BY jsi.stage_order ASC, jsi.created_at ASC\n  LOOP\n    -- Activate the next stage\n    UPDATE public.job_stage_instances\n    SET \n      status = 'active',\n      started_at = now(),\n      started_by = auth.uid(),\n      updated_at = now()\n    WHERE id = next_stage_record.id;\n  END LOOP;\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "advance_job_stage_with_parts",
    "args": "p_job_id uuid, p_job_table_name text, p_current_stage_id uuid, p_completed_by uuid, p_notes text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.advance_job_stage_with_parts(p_job_id uuid, p_job_table_name text, p_current_stage_id uuid, p_completed_by uuid DEFAULT auth.uid(), p_notes text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  current_stage RECORD;\n  next_part_stage_id UUID;\n  dependency_group UUID;\n  finishing_stages_ready BOOLEAN := false;\nBEGIN\n  -- Get current stage info\n  SELECT * INTO current_stage\n  FROM public.job_stage_instances jsi\n  JOIN public.production_stages ps ON jsi.production_stage_id = ps.id\n  WHERE jsi.job_id = p_job_id \n    AND jsi.job_table_name = p_job_table_name\n    AND jsi.production_stage_id = p_current_stage_id;\n\n  -- Complete the current stage\n  UPDATE public.job_stage_instances\n  SET \n    status = 'completed',\n    completed_at = now(),\n    completed_by = p_completed_by,\n    notes = COALESCE(p_notes, notes),\n    updated_at = now()\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND production_stage_id = p_current_stage_id\n    AND status = 'active';\n\n  -- Check if this is a part-specific chain (e.g., covers going to laminating)\n  IF current_stage.part_name = 'covers' AND EXISTS (\n    SELECT 1 FROM public.job_stage_instances jsi2\n    JOIN public.production_stages ps2 ON jsi2.production_stage_id = ps2.id\n    WHERE jsi2.job_id = p_job_id \n      AND jsi2.job_table_name = p_job_table_name\n      AND ps2.name ILIKE '%laminating%'\n      AND jsi2.part_name = 'covers'\n      AND jsi2.status = 'pending'\n  ) THEN\n    -- Activate laminating stage for covers\n    UPDATE public.job_stage_instances\n    SET \n      status = 'active',\n      started_at = now(),\n      started_by = p_completed_by,\n      updated_at = now()\n    WHERE job_id = p_job_id \n      AND job_table_name = p_job_table_name\n      AND production_stage_id IN (\n        SELECT ps.id FROM public.production_stages ps \n        WHERE ps.name ILIKE '%laminating%'\n      )\n      AND part_name = 'covers'\n      AND status = 'pending';\n  END IF;\n\n  -- Check if all printing and part-specific processing is complete for finishing stages\n  IF NOT EXISTS (\n    SELECT 1 FROM public.job_stage_instances jsi\n    JOIN public.production_stages ps ON jsi.production_stage_id = ps.id\n    WHERE jsi.job_id = p_job_id \n      AND jsi.job_table_name = p_job_table_name\n      AND (ps.name ILIKE '%printing%' OR ps.name ILIKE '%laminating%')\n      AND jsi.status NOT IN ('completed', 'skipped')\n  ) THEN\n    -- All printing and laminating complete, enable finishing stages\n    UPDATE public.job_stage_instances\n    SET \n      status = 'pending',\n      updated_at = now()\n    WHERE job_id = p_job_id \n      AND job_table_name = p_job_table_name\n      AND production_stage_id IN (\n        SELECT ps.id FROM public.production_stages ps \n        WHERE ps.name ILIKE ANY(ARRAY['%finishing%', '%gathering%', '%binding%', '%cutting%'])\n      )\n      AND status = 'blocked';\n  END IF;\n\n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "advance_job_to_batch_allocation",
    "args": "p_job_id uuid, p_job_table_name text, p_completed_by uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.advance_job_to_batch_allocation(p_job_id uuid, p_job_table_name text DEFAULT 'production_jobs'::text, p_completed_by uuid DEFAULT auth.uid())\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  proof_stage_id uuid;\n  batch_allocation_stage_id uuid;\n  current_proof_stage_instance_id uuid;\n  job_wo_no text;\nBEGIN\n  -- Get job WO number for logging\n  EXECUTE format('SELECT wo_no FROM %I WHERE id = $1', p_job_table_name)\n  INTO job_wo_no\n  USING p_job_id;\n  \n  -- Log the start of the process\n  INSERT INTO public.batch_allocation_logs (job_id, wo_no, action, details)\n  VALUES (p_job_id, job_wo_no, 'advance_start', 'Starting advance to batch allocation');\n\n  -- Find the proof stage that's currently active for this job\n  SELECT jsi.id, jsi.production_stage_id INTO current_proof_stage_instance_id, proof_stage_id\n  FROM public.job_stage_instances jsi\n  JOIN public.production_stages ps ON jsi.production_stage_id = ps.id\n  WHERE jsi.job_id = p_job_id\n    AND jsi.job_table_name = p_job_table_name\n    AND jsi.status = 'active'\n    AND ps.name ILIKE '%proof%'\n  LIMIT 1;\n  \n  IF current_proof_stage_instance_id IS NULL THEN\n    INSERT INTO public.batch_allocation_logs (job_id, wo_no, action, details)\n    VALUES (p_job_id, job_wo_no, 'error', 'No active proof stage found');\n    RAISE EXCEPTION 'No active proof stage found for job %', p_job_id;\n  END IF;\n  \n  -- Find the Batch Allocation stage\n  SELECT id INTO batch_allocation_stage_id\n  FROM public.production_stages\n  WHERE name = 'Batch Allocation'\n  LIMIT 1;\n  \n  IF batch_allocation_stage_id IS NULL THEN\n    INSERT INTO public.batch_allocation_logs (job_id, wo_no, action, details)\n    VALUES (p_job_id, job_wo_no, 'error', 'Batch Allocation stage not found');\n    RAISE EXCEPTION 'Batch Allocation stage not found';\n  END IF;\n  \n  -- Complete the proof stage\n  UPDATE public.job_stage_instances\n  SET \n    status = 'completed',\n    completed_at = now(),\n    completed_by = p_completed_by,\n    updated_at = now()\n  WHERE id = current_proof_stage_instance_id;\n  \n  INSERT INTO public.batch_allocation_logs (job_id, wo_no, action, details)\n  VALUES (p_job_id, job_wo_no, 'proof_completed', 'Proof stage marked as completed');\n  \n  -- Activate the Batch Allocation stage\n  UPDATE public.job_stage_instances\n  SET \n    status = 'active',\n    started_at = now(),\n    started_by = p_completed_by,\n    updated_at = now()\n  WHERE job_id = p_job_id\n    AND job_table_name = p_job_table_name\n    AND production_stage_id = batch_allocation_stage_id\n    AND status = 'pending';\n  \n  INSERT INTO public.batch_allocation_logs (job_id, wo_no, action, details)\n  VALUES (p_job_id, job_wo_no, 'batch_stage_activated', 'Batch Allocation stage activated');\n  \n  -- Mark job as ready for batching\n  EXECUTE format('\n    UPDATE %I \n    SET \n      batch_ready = true,\n      batch_allocated_at = now(),\n      batch_allocated_by = $1,\n      status = ''Ready for Batch'',\n      updated_at = now()\n    WHERE id = $2\n  ', p_job_table_name)\n  USING p_completed_by, p_job_id;\n  \n  INSERT INTO public.batch_allocation_logs (job_id, wo_no, action, details)\n  VALUES (p_job_id, job_wo_no, 'job_marked_ready', 'Job marked as batch_ready = true');\n  \n  INSERT INTO public.batch_allocation_logs (job_id, wo_no, action, details)\n  VALUES (p_job_id, job_wo_no, 'advance_complete', 'Successfully advanced to batch allocation');\n  \n  RETURN true;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "advance_parallel_job_stage",
    "args": "p_job_id uuid, p_job_table_name text, p_current_stage_id uuid, p_completed_by uuid, p_notes text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.advance_parallel_job_stage(p_job_id uuid, p_job_table_name text, p_current_stage_id uuid, p_completed_by uuid DEFAULT auth.uid(), p_notes text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  current_stage_record RECORD;\n  actual_duration_minutes INTEGER;\n  current_stage_order INTEGER;\n  next_stage_records RECORD;\n  dependency_group_id uuid;\n  parallel_stages_in_group INTEGER;\n  completed_stages_in_group INTEGER;\nBEGIN\n  -- Get the current stage instance details\n  SELECT jsi.*, ps.name as stage_name, jsi.dependency_group, jsi.part_assignment\n  INTO current_stage_record\n  FROM public.job_stage_instances jsi\n  JOIN public.production_stages ps ON jsi.production_stage_id = ps.id\n  WHERE jsi.job_id = p_job_id \n    AND jsi.job_table_name = p_job_table_name\n    AND jsi.production_stage_id = p_current_stage_id\n    AND jsi.status = 'active';\n  \n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Current stage not found or not active for job % stage %', p_job_id, p_current_stage_id;\n  END IF;\n  \n  -- Calculate actual duration if stage was started\n  IF current_stage_record.started_at IS NOT NULL THEN\n    actual_duration_minutes := EXTRACT(EPOCH FROM (now() - current_stage_record.started_at)) / 60;\n  END IF;\n  \n  -- Mark current stage as completed\n  UPDATE public.job_stage_instances\n  SET \n    status = 'completed',\n    completed_at = now(),\n    completed_by = p_completed_by,\n    actual_duration_minutes = actual_duration_minutes,\n    notes = COALESCE(p_notes, notes),\n    updated_at = now()\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND production_stage_id = p_current_stage_id;\n  \n  current_stage_order := current_stage_record.stage_order;\n  dependency_group_id := current_stage_record.dependency_group;\n  \n  RAISE NOTICE 'Completed stage: % (%) for job %, part: %', \n    current_stage_record.stage_name, \n    p_current_stage_id, \n    p_job_id,\n    current_stage_record.part_assignment;\n  \n  -- Find and activate next stage(s) based on part assignment and workflow logic\n  FOR next_stage_records IN\n    SELECT DISTINCT\n      jsi.id,\n      jsi.production_stage_id,\n      jsi.part_assignment,\n      jsi.dependency_group,\n      jsi.stage_order,\n      ps.name as stage_name\n    FROM public.job_stage_instances jsi\n    JOIN public.production_stages ps ON jsi.production_stage_id = ps.id\n    WHERE jsi.job_id = p_job_id \n      AND jsi.job_table_name = p_job_table_name\n      AND jsi.stage_order > current_stage_order\n      AND jsi.status = 'pending'\n      AND (\n        -- FIXED: Better part assignment matching logic\n        -- Case 1: Current completed stage was 'both' - activate all next stages\n        (current_stage_record.part_assignment = 'both') OR\n        -- Case 2: Current completed stage was specific part - activate matching part stages and 'both' stages\n        (current_stage_record.part_assignment IS NOT NULL AND \n         (jsi.part_assignment = current_stage_record.part_assignment OR jsi.part_assignment = 'both')) OR\n        -- Case 3: Current completed stage had no part assignment - activate all\n        (current_stage_record.part_assignment IS NULL) OR\n        -- Case 4: Next stage has no part assignment - activate it\n        (jsi.part_assignment IS NULL)\n      )\n    ORDER BY jsi.stage_order ASC\n    LIMIT 20 -- Reasonable limit to prevent infinite loops\n  LOOP\n    -- Check if this stage has dependency requirements that are met\n    IF next_stage_records.dependency_group IS NOT NULL THEN\n      -- For dependency groups, check if all required stages at previous orders are completed\n      SELECT COUNT(*) INTO parallel_stages_in_group\n      FROM public.job_stage_instances\n      WHERE job_id = p_job_id \n        AND job_table_name = p_job_table_name\n        AND dependency_group = next_stage_records.dependency_group\n        AND stage_order < next_stage_records.stage_order;\n      \n      SELECT COUNT(*) INTO completed_stages_in_group\n      FROM public.job_stage_i"
  },
  {
    "function_schema": "public",
    "function_name": "any_admin_exists",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.any_admin_exists()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  -- Check if any user has admin role in the user_roles table\n  RETURN EXISTS (\n    SELECT 1\n    FROM public.user_roles\n    WHERE role = 'admin'\n  );\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "apply_stage_updates_safe",
    "args": "updates jsonb, commit boolean, only_if_unset boolean, as_proposed boolean",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.apply_stage_updates_safe(updates jsonb, commit boolean DEFAULT true, only_if_unset boolean DEFAULT true, as_proposed boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\ndeclare\r\n  _rows               int := 0;\r\n  _applied            int := 0;\r\n  _skipped_exists     int := 0;\r\n  _skipped_inprogress int := 0;\r\n  _skipped_manual     int := 0;\r\nbegin\r\n  -- Normalize payload\r\n  create temporary table _sched_updates\r\n  on commit drop\r\n  as\r\n  select\r\n    (x->>'id')::uuid                      as id,\r\n    (x->>'start_at')::timestamptz         as start_at,\r\n    (x->>'end_at')::timestamptz           as end_at,\r\n    greatest(1, coalesce((x->>'minutes')::int, 1)) as minutes\r\n  from jsonb_array_elements(coalesce(updates, '[]'::jsonb)) as x;\r\n\r\n  get diagnostics _rows = row_count;\r\n\r\n  -- Join to JSI to collect fields required by stage_time_slots\r\n  create temporary table _eligible\r\n  on commit drop\r\n  as\r\n  select\r\n    jsi.id                       as stage_instance_id,\r\n    jsi.job_id,\r\n    jsi.job_table_name,\r\n    jsi.production_stage_id,\r\n    u.start_at,\r\n    u.end_at,\r\n    u.minutes                   as duration_minutes,\r\n    case\r\n      when jsi.status in ('in_progress') then 'in_progress'\r\n      when jsi.schedule_status in ('manual') then 'manual'\r\n      else 'ok'\r\n    end as reason\r\n  from _sched_updates u\r\n  join job_stage_instances jsi on jsi.id = u.id;\r\n\r\n  -- Tally skips then keep only schedulable rows\r\n  select count(*) into _skipped_inprogress from _eligible where reason = 'in_progress';\r\n  select count(*) into _skipped_manual     from _eligible where reason = 'manual';\r\n  delete from _eligible where reason <> 'ok';\r\n\r\n  -- Optionally skip rows that already have schedule set\r\n  if only_if_unset then\r\n    delete from _eligible e\r\n    using job_stage_instances j\r\n    where j.id = e.stage_instance_id\r\n      and (\r\n            j.scheduled_start_at is not null\r\n         or j.scheduled_end_at   is not null\r\n         or coalesce(j.scheduled_minutes,0) > 0\r\n      );\r\n    get diagnostics _skipped_exists = row_count;\r\n  end if;\r\n\r\n  if commit then\r\n    -- Replace any existing slots for these stage instances\r\n    delete from stage_time_slots sts\r\n    using _eligible e\r\n    where sts.stage_instance_id = e.stage_instance_id;\r\n\r\n    -- Insert new slots with your schema's columns (duration_minutes, date, etc.)\r\n    insert into stage_time_slots (\r\n      stage_instance_id,\r\n      production_stage_id,\r\n      date,\r\n      slot_start_time,\r\n      slot_end_time,\r\n      duration_minutes,\r\n      job_id,\r\n      job_table_name\r\n    )\r\n    select\r\n      e.stage_instance_id,\r\n      e.production_stage_id,\r\n      e.start_at::date,\r\n      e.start_at,\r\n      e.end_at,\r\n      e.duration_minutes,\r\n      e.job_id,\r\n      e.job_table_name\r\n    from _eligible e;\r\n\r\n    get diagnostics _applied = row_count;\r\n\r\n    -- Mirror schedule on JSI\r\n    update job_stage_instances j\r\n    set scheduled_start_at = e.start_at,\r\n        scheduled_end_at   = e.end_at,\r\n        scheduled_minutes  = e.duration_minutes,\r\n        schedule_status    = case when as_proposed then 'proposed' else 'scheduled' end,\r\n        scheduling_method  = 'auto',\r\n        updated_at         = now()\r\n    from _eligible e\r\n    where j.id = e.stage_instance_id;\r\n  end if;\r\n\r\n  return jsonb_build_object(\r\n    'rows',               _rows,\r\n    'applied',            _applied,\r\n    'skipped_exists',     _skipped_exists,\r\n    'skipped_manual',     _skipped_manual,\r\n    'skipped_inprogress', _skipped_inprogress\r\n  );\r\nend\r\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "auto_create_batch_job_references",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.auto_create_batch_job_references()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  batch_table_name text;\n  production_job_id_found uuid;\nBEGIN\n  -- Determine the table name based on the trigger source\n  batch_table_name := TG_TABLE_NAME;\n  \n  -- Only create reference if batch_id is being set (not null)\n  IF NEW.batch_id IS NOT NULL AND (OLD.batch_id IS NULL OR OLD.batch_id != NEW.batch_id) THEN\n    -- Find the corresponding production job by job_number\n    SELECT pj.id INTO production_job_id_found\n    FROM public.production_jobs pj\n    WHERE pj.wo_no = NEW.job_number\n    LIMIT 1;\n    \n    -- Only create reference if we found a matching production job\n    IF production_job_id_found IS NOT NULL THEN\n      INSERT INTO public.batch_job_references (\n        batch_id,\n        batch_job_id,\n        batch_job_table,\n        production_job_id,\n        status,\n        created_at\n      ) VALUES (\n        NEW.batch_id,\n        NEW.id,\n        batch_table_name,\n        production_job_id_found,\n        'pending',\n        now()\n      ) ON CONFLICT (production_job_id, batch_id) DO UPDATE SET\n        batch_job_id = EXCLUDED.batch_job_id,\n        batch_job_table = EXCLUDED.batch_job_table,\n        status = EXCLUDED.status,\n        created_at = EXCLUDED.created_at;\n      \n      RAISE NOTICE 'Created/updated batch job reference for % job % in batch %', batch_table_name, NEW.job_number, NEW.batch_id;\n    END IF;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "auto_schedule_job_on_approval",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.auto_schedule_job_on_approval()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Only trigger when status changes to 'In Production' or similar approved state\n  IF NEW.status = 'In Production' AND (OLD.status IS NULL OR OLD.status != 'In Production') THEN\n    -- Call the auto-scheduler edge function asynchronously\n    PERFORM net.http_post(\n      url := 'https://kgizusgqexmlfcqfjopk.supabase.co/functions/v1/auto-scheduler',\n      headers := '{\"Content-Type\": \"application/json\", \"Authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtnaXp1c2dxZXhtbGZjcWZqb3BrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ1NTQwNzAsImV4cCI6MjA2MDEzMDA3MH0.NA2wRme-L8Z15my7n8u-BCQtO4Nw2opfsX0KSLYcs-I\"}'::jsonb,\n      body := json_build_object(\n        'job_id', NEW.id,\n        'job_table_name', 'production_jobs',\n        'trigger_reason', 'job_approved'\n      )::jsonb\n    );\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "auto_split_batch_at_packaging",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.auto_split_batch_at_packaging()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  packaging_stage_id uuid;\n  split_result RECORD;\nBEGIN\n  -- Only process if this is a batch master job reaching packaging stage\n  IF NEW.status = 'active' AND OLD.status = 'pending' THEN\n    -- Check if this stage is packaging and job is batch master\n    SELECT ps.id INTO packaging_stage_id\n    FROM public.production_stages ps\n    WHERE ps.id = NEW.production_stage_id\n      AND ps.name ILIKE '%packaging%';\n    \n    IF packaging_stage_id IS NOT NULL THEN\n      -- Check if the job is a batch master\n      IF EXISTS (\n        SELECT 1 FROM public.production_jobs pj\n        WHERE pj.id = NEW.job_id AND pj.is_batch_master = true\n      ) THEN\n        -- Split the batch automatically\n        SELECT * INTO split_result\n        FROM public.split_batch_at_packaging(NEW.job_id, NEW.started_by);\n        \n        RAISE NOTICE 'Auto-split batch master job % - split % constituent jobs', \n          NEW.job_id, split_result.split_jobs_count;\n      END IF;\n    END IF;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "auto_sync_batch_job_status",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.auto_sync_batch_job_status()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Only process when status changes to 'Completed'\n  IF NEW.status = 'Completed' AND (OLD.status IS NULL OR OLD.status != 'Completed') THEN\n    -- Update related batch jobs to completed status\n    PERFORM public.sync_completed_jobs_with_batch_flow();\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "auto_sync_production_jobs_on_batch_completion",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.auto_sync_production_jobs_on_batch_completion()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Only process when batch status changes to 'completed'\n  IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN\n    -- Update related production jobs to completed status\n    PERFORM public.sync_production_jobs_from_batch_completion();\n    RAISE NOTICE 'Batch % marked as completed - syncing production jobs', NEW.name;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "bulk_recalculate_job_due_dates",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.bulk_recalculate_job_due_dates()\n RETURNS TABLE(updated_job_id uuid, old_due_date date, new_due_date date, estimated_hours numeric)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  job_record RECORD;\n  total_hours numeric := 0;\n  new_due_date date;\n  current_workload_days integer := 0;\nBEGIN\n  -- Get current workload in days\n  SELECT COALESCE(SUM(total_estimated_hours), 0) / 8 INTO current_workload_days\n  FROM public.daily_workload \n  WHERE date >= CURRENT_DATE;\n  \n  -- Process each production job that needs rescheduling\n  FOR job_record IN\n    SELECT \n      pj.id,\n      pj.due_date as old_due_date,\n      COALESCE(SUM(jsi.estimated_duration_minutes), 0) / 60.0 as total_estimated_hours\n    FROM public.production_jobs pj\n    LEFT JOIN public.job_stage_instances jsi ON (\n      jsi.job_id = pj.id \n      AND jsi.job_table_name = 'production_jobs'\n      AND jsi.status IN ('pending', 'active')\n    )\n    WHERE pj.status NOT IN ('completed', 'cancelled')\n    GROUP BY pj.id, pj.due_date\n    ORDER BY pj.created_at ASC\n  LOOP\n    -- Calculate working days needed (including current workload)\n    total_hours := total_hours + job_record.total_estimated_hours;\n    \n    -- Add 1 day buffer as requested\n    new_due_date := (CURRENT_DATE + INTERVAL '1 day' * (CEIL(total_hours / 8) + 1))::date;\n    \n    -- Update the job with new due date\n    UPDATE public.production_jobs\n    SET \n      due_date = new_due_date,\n      updated_at = now()\n    WHERE id = job_record.id;\n    \n    -- Return the update info\n    RETURN QUERY SELECT \n      job_record.id,\n      job_record.old_due_date,\n      new_due_date,\n      job_record.total_estimated_hours;\n  END LOOP;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "calculate_smart_due_date",
    "args": "p_estimated_hours numeric, p_priority integer",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.calculate_smart_due_date(p_estimated_hours numeric, p_priority integer DEFAULT 100)\n RETURNS date\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  current_date DATE := CURRENT_DATE;\n  working_day DATE;\n  total_workload DECIMAL := 0;\n  daily_capacity INTEGER := 8;\n  days_needed INTEGER;\nBEGIN\n  -- Calculate total workload from existing scheduled jobs\n  SELECT COALESCE(SUM(estimated_total_hours), 0) \n  INTO total_workload\n  FROM public.job_scheduling js\n  WHERE js.scheduled_start_date >= current_date;\n  \n  -- Add the new job's workload\n  total_workload := total_workload + p_estimated_hours;\n  \n  -- Calculate working days needed (8 hours per day)\n  days_needed := CEIL(total_workload / daily_capacity);\n  \n  -- Find the target working day\n  working_day := current_date;\n  WHILE days_needed > 0 LOOP\n    working_day := working_day + INTERVAL '1 day';\n    \n    -- Skip weekends and check if it's a working day\n    IF EXTRACT(DOW FROM working_day) NOT IN (0, 6) \n       AND NOT EXISTS (\n         SELECT 1 FROM public.public_holidays \n         WHERE date = working_day AND is_active = true\n       ) THEN\n      days_needed := days_needed - 1;\n    END IF;\n  END LOOP;\n  \n  RETURN working_day;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "calculate_stage_duration",
    "args": "p_quantity integer, p_running_speed_per_hour integer, p_make_ready_time_minutes integer, p_speed_unit text",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.calculate_stage_duration(p_quantity integer, p_running_speed_per_hour integer, p_make_ready_time_minutes integer DEFAULT 10, p_speed_unit text DEFAULT 'sheets_per_hour'::text)\n RETURNS integer\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n  production_minutes INTEGER;\n  total_minutes INTEGER;\nBEGIN\n  -- Handle null or zero values\n  IF p_quantity IS NULL OR p_quantity <= 0 OR p_running_speed_per_hour IS NULL OR p_running_speed_per_hour <= 0 THEN\n    RETURN COALESCE(p_make_ready_time_minutes, 10);\n  END IF;\n  \n  -- Calculate production time based on speed unit\n  CASE p_speed_unit\n    WHEN 'sheets_per_hour', 'items_per_hour' THEN\n      production_minutes := CEIL((p_quantity::NUMERIC / p_running_speed_per_hour::NUMERIC) * 60);\n    WHEN 'minutes_per_item' THEN\n      production_minutes := p_quantity * p_running_speed_per_hour;\n    ELSE\n      production_minutes := CEIL((p_quantity::NUMERIC / p_running_speed_per_hour::NUMERIC) * 60);\n  END CASE;\n  \n  -- Add make-ready time\n  total_minutes := production_minutes + COALESCE(p_make_ready_time_minutes, 10);\n  \n  RETURN total_minutes;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "calculate_stage_duration_with_type",
    "args": "p_quantity integer, p_running_speed_per_hour integer, p_make_ready_time_minutes integer, p_speed_unit text, p_quantity_type text",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.calculate_stage_duration_with_type(p_quantity integer, p_running_speed_per_hour integer, p_make_ready_time_minutes integer DEFAULT 10, p_speed_unit text DEFAULT 'sheets_per_hour'::text, p_quantity_type text DEFAULT 'pieces'::text)\n RETURNS integer\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n  production_minutes INTEGER;\n  total_minutes INTEGER;\n  effective_quantity INTEGER;\nBEGIN\n  -- Handle null or zero values\n  IF p_quantity IS NULL OR p_quantity <= 0 OR p_running_speed_per_hour IS NULL OR p_running_speed_per_hour <= 0 THEN\n    RETURN COALESCE(p_make_ready_time_minutes, 10);\n  END IF;\n  \n  -- Adjust quantity based on quantity type and stage requirements\n  effective_quantity := p_quantity;\n  \n  -- For printing stages, typically use sheets\n  -- For finishing stages, typically use pieces\n  -- For operations, use the raw count\n  CASE p_quantity_type\n    WHEN 'sheets' THEN\n      -- For sheet-based operations (printing), use quantity as-is\n      effective_quantity := p_quantity;\n    WHEN 'pieces' THEN\n      -- For piece-based operations (finishing), use quantity as-is\n      effective_quantity := p_quantity;\n    WHEN 'operations' THEN\n      -- For operation count, use quantity as-is\n      effective_quantity := p_quantity;\n    ELSE\n      -- Default to pieces\n      effective_quantity := p_quantity;\n  END CASE;\n  \n  -- Calculate production time based on speed unit\n  CASE p_speed_unit\n    WHEN 'sheets_per_hour', 'items_per_hour', 'pieces_per_hour' THEN\n      production_minutes := CEIL((effective_quantity::NUMERIC / p_running_speed_per_hour::NUMERIC) * 60);\n    WHEN 'minutes_per_item', 'minutes_per_piece' THEN\n      production_minutes := effective_quantity * p_running_speed_per_hour;\n    ELSE\n      production_minutes := CEIL((effective_quantity::NUMERIC / p_running_speed_per_hour::NUMERIC) * 60);\n  END CASE;\n  \n  -- Add make-ready time\n  total_minutes := production_minutes + COALESCE(p_make_ready_time_minutes, 10);\n  \n  RETURN total_minutes;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "calculate_stage_queue_workload",
    "args": "p_production_stage_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.calculate_stage_queue_workload(p_production_stage_id uuid)\n RETURNS TABLE(total_pending_hours numeric, total_active_hours numeric, pending_jobs_count integer, active_jobs_count integer, earliest_available_slot timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  stage_capacity RECORD;\n  daily_hours DECIMAL(8,2);\nBEGIN\n  -- Get stage capacity info\n  SELECT daily_capacity_hours, efficiency_factor\n  INTO stage_capacity\n  FROM public.stage_capacity_profiles\n  WHERE production_stage_id = p_production_stage_id;\n  \n  IF NOT FOUND THEN\n    -- Default capacity if not configured\n    daily_hours := 8.0;\n  ELSE\n    daily_hours := stage_capacity.daily_capacity_hours * stage_capacity.efficiency_factor;\n  END IF;\n  \n  RETURN QUERY\n  SELECT \n    COALESCE(SUM(CASE WHEN jsi.status = 'pending' THEN jsi.estimated_duration_minutes END), 0) / 60.0 as total_pending_hours,\n    COALESCE(SUM(CASE WHEN jsi.status = 'active' THEN jsi.estimated_duration_minutes END), 0) / 60.0 as total_active_hours,\n    COUNT(CASE WHEN jsi.status = 'pending' THEN 1 END)::INTEGER as pending_jobs_count,\n    COUNT(CASE WHEN jsi.status = 'active' THEN 1 END)::INTEGER as active_jobs_count,\n    (now() + INTERVAL '1 hour' * (COALESCE(SUM(jsi.estimated_duration_minutes), 0) / 60.0 / daily_hours)) as earliest_available_slot\n  FROM public.job_stage_instances jsi\n  WHERE jsi.production_stage_id = p_production_stage_id\n    AND jsi.status IN ('pending', 'active');\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "calculate_stage_queue_workload",
    "args": "stage_ids uuid[]",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.calculate_stage_queue_workload(stage_ids uuid[])\n RETURNS TABLE(stage_id uuid, total_pending_hours numeric, total_active_hours numeric, pending_jobs_count integer, active_jobs_count integer, earliest_available_slot timestamp with time zone, queue_processing_hours numeric)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  stage_record RECORD;\n  stage_capacity RECORD;\n  daily_hours DECIMAL(8,2);\nBEGIN\n  FOR stage_record IN \n    SELECT UNNEST(stage_ids) as sid\n  LOOP\n    -- Get stage capacity info\n    SELECT daily_capacity_hours, efficiency_factor\n    INTO stage_capacity\n    FROM public.stage_capacity_profiles\n    WHERE production_stage_id = stage_record.sid;\n    \n    IF NOT FOUND THEN\n      -- Default capacity if not configured\n      daily_hours := 8.0;\n    ELSE\n      daily_hours := stage_capacity.daily_capacity_hours * stage_capacity.efficiency_factor;\n    END IF;\n    \n    -- Calculate workload for this stage\n    RETURN QUERY\n    SELECT \n      stage_record.sid as stage_id,\n      COALESCE(SUM(CASE WHEN jsi.status = 'pending' THEN jsi.estimated_duration_minutes END), 0) / 60.0 as total_pending_hours,\n      COALESCE(SUM(CASE WHEN jsi.status = 'active' THEN jsi.estimated_duration_minutes END), 0) / 60.0 as total_active_hours,\n      COUNT(CASE WHEN jsi.status = 'pending' THEN 1 END)::INTEGER as pending_jobs_count,\n      COUNT(CASE WHEN jsi.status = 'active' THEN 1 END)::INTEGER as active_jobs_count,\n      (now() + INTERVAL '1 hour' * (COALESCE(SUM(jsi.estimated_duration_minutes), 0) / 60.0 / daily_hours)) as earliest_available_slot,\n      (COALESCE(SUM(jsi.estimated_duration_minutes), 0) / 60.0) as queue_processing_hours\n    FROM public.job_stage_instances jsi\n    WHERE jsi.production_stage_id = stage_record.sid\n      AND jsi.status IN ('pending', 'active');\n  END LOOP;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "can_user_start_new_job",
    "args": "p_user_id uuid, p_department_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.can_user_start_new_job(p_user_id uuid, p_department_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  current_active_jobs INTEGER;\n  max_allowed INTEGER;\n  allows_concurrent BOOLEAN;\nBEGIN\n  -- Get department settings\n  SELECT allows_concurrent_jobs, max_concurrent_jobs\n  INTO allows_concurrent, max_allowed\n  FROM public.departments\n  WHERE id = p_department_id;\n  \n  -- If concurrent jobs not allowed, check if user has any active jobs\n  IF NOT allows_concurrent THEN\n    SELECT COUNT(*) INTO current_active_jobs\n    FROM public.active_job_assignments\n    WHERE user_id = p_user_id;\n    \n    RETURN current_active_jobs = 0;\n  END IF;\n  \n  -- If concurrent jobs allowed, check against max limit\n  SELECT COUNT(*) INTO current_active_jobs\n  FROM public.active_job_assignments\n  WHERE user_id = p_user_id AND department_id = p_department_id;\n  \n  RETURN current_active_jobs < max_allowed;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "check_admin_exists",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.check_admin_exists()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 \n    FROM public.user_roles \n    WHERE role = 'admin'\n  );\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "check_dependency_completion",
    "args": "p_job_id uuid, p_job_table_name text, p_dependency_group uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.check_dependency_completion(p_job_id uuid, p_job_table_name text, p_dependency_group uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  total_stages INTEGER;\n  completed_stages INTEGER;\nBEGIN\n  -- If no dependency group specified, consider it completed\n  IF p_dependency_group IS NULL THEN\n    RETURN true;\n  END IF;\n  \n  -- Count total stages in the dependency group\n  SELECT COUNT(*) INTO total_stages\n  FROM public.job_stage_instances\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND dependency_group = p_dependency_group;\n  \n  -- Count completed stages in the dependency group\n  SELECT COUNT(*) INTO completed_stages\n  FROM public.job_stage_instances\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND dependency_group = p_dependency_group\n    AND status = 'completed';\n  \n  -- Return true only if all stages in the group are completed\n  RETURN (total_stages > 0 AND completed_stages = total_stages);\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "check_user_admin_status",
    "args": "check_user_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.check_user_admin_status(check_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 \n    FROM public.user_roles \n    WHERE user_id = check_user_id \n    AND role = 'admin'\n  );\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "check_user_is_admin",
    "args": "check_user_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.check_user_is_admin(check_user_id uuid DEFAULT auth.uid())\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  user_role text;\nBEGIN\n  -- Simple direct query without recursion\n  SELECT role INTO user_role\n  FROM public.user_roles \n  WHERE user_id = check_user_id\n  LIMIT 1;\n  \n  RETURN COALESCE(user_role = 'admin', false);\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "cleanup_corrupted_batch_jobs",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.cleanup_corrupted_batch_jobs()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  batch_table_names text[] := ARRAY['business_card_jobs', 'flyer_jobs', 'postcard_jobs', 'poster_jobs', 'sticker_jobs', 'cover_jobs', 'sleeve_jobs', 'box_jobs'];\n  current_table text;\n  total_fixed integer := 0;\nBEGIN\n  -- Loop through each batch job table\n  FOREACH current_table IN ARRAY batch_table_names LOOP\n    -- Fix job numbers that have BATCH- prefix and timestamps\n    EXECUTE format('\n      UPDATE %I SET \n        job_number = REGEXP_REPLACE(job_number, ''^BATCH-(.+?)-[0-9]+$'', ''\\1''),\n        updated_at = now()\n      WHERE job_number SIMILAR TO ''BATCH-%%[0-9]+''\n    ', current_table);\n    \n    -- Update names from generic \"Batch Job - XXX\" to actual customer names from production jobs\n    EXECUTE format('\n      UPDATE %I SET \n        name = pj.customer,\n        updated_at = now()\n      FROM public.batch_job_references bjr\n      JOIN public.production_jobs pj ON bjr.production_job_id = pj.id\n      WHERE %I.id = bjr.batch_job_id\n        AND bjr.batch_job_table = %L\n        AND %I.name LIKE ''Batch Job - %%''\n        AND pj.customer IS NOT NULL\n        AND pj.customer != ''''\n    ', current_table, current_table, current_table, current_table);\n    \n    RAISE NOTICE 'Cleaned up batch jobs in table: %', current_table;\n  END LOOP;\n  \n  RETURN true;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "cleanup_production_job_data",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.cleanup_production_job_data()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Clean up job stage instances\n  DELETE FROM job_stage_instances WHERE job_id = OLD.id AND job_table_name = 'production_jobs';\n  \n  -- Clean up job print specifications\n  DELETE FROM job_print_specifications WHERE job_id = OLD.id AND job_table_name = 'production_jobs';\n  \n  -- Clean up proof links\n  DELETE FROM proof_links WHERE job_id = OLD.id AND job_table_name = 'production_jobs';\n  \n  -- Clean up active job assignments\n  DELETE FROM active_job_assignments WHERE job_id = OLD.id AND job_table_name = 'production_jobs';\n  \n  -- Clean up due date recalculation queue\n  DELETE FROM due_date_recalculation_queue WHERE job_id = OLD.id AND job_table_name = 'production_jobs';\n  \n  -- Clean up job priority overrides\n  DELETE FROM job_priority_overrides WHERE job_id = OLD.id AND job_table_name = 'production_jobs';\n  \n  -- Clean up batch job references\n  DELETE FROM batch_job_references WHERE production_job_id = OLD.id;\n  \n  RETURN OLD;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "clear_all_stage_time_slots",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.clear_all_stage_time_slots()\n RETURNS TABLE(deleted_slots_count integer, deleted_instances_count integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  slots_count integer;\n  instances_count integer;\nBEGIN\n  -- Count existing records before deletion\n  SELECT COUNT(*) INTO slots_count FROM public.stage_time_slots;\n  SELECT COUNT(*) INTO instances_count FROM public.job_stage_instances WHERE schedule_status = 'scheduled';\n  \n  -- Clear all stage time slots\n  DELETE FROM public.stage_time_slots;\n  \n  -- Reset schedule status on job stage instances\n  UPDATE public.job_stage_instances \n  SET \n    schedule_status = 'unscheduled',\n    auto_scheduled_start_at = NULL,\n    auto_scheduled_end_at = NULL,\n    auto_scheduled_duration_minutes = NULL,\n    updated_at = now()\n  WHERE schedule_status = 'scheduled';\n  \n  -- Return counts of deleted records\n  RETURN QUERY SELECT slots_count, instances_count;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "consolidate_excel_mappings",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.consolidate_excel_mappings()\n RETURNS TABLE(merged_count integer, conflict_count integer, consolidation_log jsonb)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  merge_count integer := 0;\n  conflict_count integer := 0;\n  log_entries jsonb := '[]'::jsonb;\n  duplicate_record RECORD;\nBEGIN\n  -- Only allow admins to run consolidation\n  IF NOT EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin') THEN\n    RAISE EXCEPTION 'Admin access required for mapping consolidation';\n  END IF;\n  \n  -- Find and log conflicts (same text, different stages)\n  FOR duplicate_record IN\n    SELECT \n      excel_text,\n      COUNT(DISTINCT production_stage_id) as stage_count,\n      array_agg(DISTINCT production_stage_id) as stage_ids\n    FROM public.excel_import_mappings\n    GROUP BY excel_text\n    HAVING COUNT(DISTINCT production_stage_id) > 1\n  LOOP\n    conflict_count := conflict_count + 1;\n    log_entries := log_entries || jsonb_build_object(\n      'type', 'conflict',\n      'excel_text', duplicate_record.excel_text,\n      'stage_count', duplicate_record.stage_count,\n      'stage_ids', duplicate_record.stage_ids\n    );\n  END LOOP;\n  \n  RETURN QUERY SELECT merge_count, conflict_count, log_entries;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "create_batch_job_reference_automatically",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.create_batch_job_reference_automatically()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  batch_table_name text;\n  production_job_id_found uuid;\n  job_number_to_match text;\nBEGIN\n  -- Determine the table name based on the trigger source\n  batch_table_name := TG_TABLE_NAME;\n  \n  -- Only create reference if batch_id is being set (not null)\n  IF NEW.batch_id IS NOT NULL AND (OLD IS NULL OR OLD.batch_id IS NULL OR OLD.batch_id != NEW.batch_id) THEN\n    \n    -- Get the job number to match - handle different column names gracefully\n    job_number_to_match := NEW.job_number;\n    \n    IF job_number_to_match IS NULL OR job_number_to_match = '' THEN\n      RAISE NOTICE 'No job number found for % job ID % - skipping batch reference creation', batch_table_name, NEW.id;\n      RETURN NEW;\n    END IF;\n    \n    -- Find the corresponding production job by job_number/wo_no\n    SELECT pj.id INTO production_job_id_found\n    FROM public.production_jobs pj\n    WHERE pj.wo_no = job_number_to_match\n    LIMIT 1;\n    \n    -- Only create reference if we found a matching production job\n    IF production_job_id_found IS NOT NULL THEN\n      INSERT INTO public.batch_job_references (\n        batch_id,\n        batch_job_id,\n        batch_job_table,\n        production_job_id,\n        status,\n        created_at\n      ) VALUES (\n        NEW.batch_id,\n        NEW.id,\n        batch_table_name,\n        production_job_id_found,\n        'pending',\n        now()\n      ) ON CONFLICT (production_job_id, batch_id) DO UPDATE SET\n        batch_job_id = EXCLUDED.batch_job_id,\n        batch_job_table = EXCLUDED.batch_job_table,\n        status = EXCLUDED.status,\n        created_at = EXCLUDED.created_at;\n      \n      RAISE NOTICE 'Created batch job reference: % job % (ID: %) -> production job % in batch %', \n        batch_table_name, job_number_to_match, NEW.id, production_job_id_found, NEW.batch_id;\n    ELSE\n      RAISE NOTICE 'No matching production job found for % job % (ID: %) - batch reference not created (this is OK)', \n        batch_table_name, job_number_to_match, NEW.id;\n    END IF;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "create_batch_master_job",
    "args": "p_batch_id uuid, p_constituent_job_ids uuid[]",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.create_batch_master_job(p_batch_id uuid, p_constituent_job_ids uuid[])\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  master_job_id uuid;\n  batch_record RECORD;\n  total_qty integer := 0;\n  earliest_due_date date;\n  batch_name text;\n  constituent_jobs_count integer;\nBEGIN\n  -- Validate inputs\n  IF p_batch_id IS NULL THEN\n    RAISE EXCEPTION 'Batch ID cannot be null';\n  END IF;\n  \n  IF p_constituent_job_ids IS NULL OR array_length(p_constituent_job_ids, 1) = 0 THEN\n    RAISE EXCEPTION 'Constituent job IDs array cannot be null or empty';\n  END IF;\n\n  -- Get batch details\n  SELECT b.name, b.due_date INTO batch_record\n  FROM public.batches b\n  WHERE b.id = p_batch_id;\n  \n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Batch % not found', p_batch_id;\n  END IF;\n\n  -- Validate that all constituent jobs exist\n  SELECT COUNT(*) INTO constituent_jobs_count\n  FROM public.production_jobs pj\n  WHERE pj.id = ANY(p_constituent_job_ids);\n  \n  IF constituent_jobs_count != array_length(p_constituent_job_ids, 1) THEN\n    RAISE EXCEPTION 'Not all constituent jobs found. Expected %, found %', \n      array_length(p_constituent_job_ids, 1), constituent_jobs_count;\n  END IF;\n\n  -- Calculate aggregate values from constituent jobs\n  SELECT \n    COALESCE(SUM(pj.qty), 0),\n    MIN(pj.due_date),\n    'BATCH-' || batch_record.name || '-' || to_char(now(), 'YYYYMMDDHH24MISS')\n  INTO total_qty, earliest_due_date, batch_name\n  FROM public.production_jobs pj\n  WHERE pj.id = ANY(p_constituent_job_ids);\n\n  -- Generate unique master job ID\n  master_job_id := gen_random_uuid();\n\n  -- Create the batch master job\n  INSERT INTO public.production_jobs (\n    id,\n    user_id,\n    wo_no,\n    customer,\n    reference,\n    qty,\n    due_date,\n    status,\n    is_batch_master,\n    batch_category,\n    created_at,\n    updated_at\n  )\n  SELECT \n    master_job_id,\n    auth.uid(),\n    batch_name,\n    'BATCH: ' || string_agg(DISTINCT COALESCE(pj.customer, 'Unknown'), ', '),\n    'Batch containing ' || array_length(p_constituent_job_ids, 1) || ' jobs',\n    total_qty,\n    COALESCE(earliest_due_date, batch_record.due_date::date),\n    'Ready to Print',\n    TRUE,\n    'mixed',\n    now(),\n    now()\n  FROM public.production_jobs pj\n  WHERE pj.id = ANY(p_constituent_job_ids);\n\n  -- Log the creation\n  RAISE NOTICE 'Created batch master job % for batch % with % constituent jobs', \n    master_job_id, p_batch_id, array_length(p_constituent_job_ids, 1);\n\n  -- Update constituent jobs to reference the master\n  UPDATE public.production_jobs\n  SET \n    status = 'In Batch Processing',\n    batch_ready = true,\n    updated_at = now()\n  WHERE id = ANY(p_constituent_job_ids);\n\n  -- Initialize workflow stages for the master job\n  PERFORM public.initialize_job_stages_auto(master_job_id, 'production_jobs', null);\n\n  RETURN master_job_id;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "create_batch_master_job",
    "args": "p_batch_id uuid, p_constituent_job_ids uuid[], p_created_by uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.create_batch_master_job(p_batch_id uuid, p_constituent_job_ids uuid[], p_created_by uuid DEFAULT auth.uid())\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  master_job_id uuid;\n  primary_job_record RECORD;\n  job_count integer;\n  batch_name text;\nBEGIN\n  -- Get the primary job details (first job in the array)\n  SELECT * INTO primary_job_record\n  FROM public.production_jobs\n  WHERE id = p_constituent_job_ids[1];\n  \n  IF primary_job_record IS NULL THEN\n    RAISE EXCEPTION 'Primary job not found';\n  END IF;\n  \n  -- Get batch name\n  SELECT name INTO batch_name\n  FROM public.batches\n  WHERE id = p_batch_id;\n  \n  job_count := array_length(p_constituent_job_ids, 1);\n  \n  -- Create batch master job preserving primary job's WO number\n  INSERT INTO public.production_jobs (\n    wo_no,\n    customer,\n    reference,\n    status,\n    category_id,\n    batch_category,\n    user_id,\n    qty,\n    due_date,\n    is_batch_master,\n    batch_ready\n  ) VALUES (\n    primary_job_record.wo_no || '-BATCH',\n    'BATCH: ' || COALESCE(primary_job_record.customer, 'Multiple Customers'),\n    format('Batch master for %s jobs: %s', job_count, batch_name),\n    'In Batch Processing',\n    primary_job_record.category_id,\n    batch_name,\n    p_created_by,\n    job_count,\n    primary_job_record.due_date,\n    true,\n    false\n  )\n  RETURNING id INTO master_job_id;\n  \n  -- Initialize workflow for batch master job\n  IF primary_job_record.category_id IS NOT NULL THEN\n    PERFORM public.initialize_job_stages_auto(\n      master_job_id,\n      'production_jobs',\n      primary_job_record.category_id\n    );\n  END IF;\n  \n  -- Update batch job references to point to the master job\n  UPDATE public.batch_job_references\n  SET \n    batch_job_id = master_job_id,\n    batch_job_table = 'production_jobs',\n    status = 'in_batch',\n    updated_at = now()\n  WHERE batch_id = p_batch_id\n    AND production_job_id = ANY(p_constituent_job_ids);\n  \n  -- Update constituent jobs to reflect batch processing\n  UPDATE public.production_jobs\n  SET \n    status = 'In Batch Processing',\n    batch_ready = false,\n    updated_at = now()\n  WHERE id = ANY(p_constituent_job_ids);\n  \n  RETURN master_job_id;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "create_batch_master_job_simple",
    "args": "p_batch_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.create_batch_master_job_simple(p_batch_id uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  batch_record RECORD;\n  constituent_job_ids uuid[];\n  master_job_id uuid;\nBEGIN\n  -- Validate batch exists\n  SELECT * INTO batch_record FROM public.batches WHERE id = p_batch_id;\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Batch with ID % not found', p_batch_id;\n  END IF;\n  \n  -- Get constituent job IDs from batch references\n  SELECT array_agg(production_job_id) INTO constituent_job_ids\n  FROM public.batch_job_references\n  WHERE batch_id = p_batch_id;\n  \n  IF constituent_job_ids IS NULL OR array_length(constituent_job_ids, 1) = 0 THEN\n    RAISE EXCEPTION 'No constituent jobs found for batch %', p_batch_id;\n  END IF;\n  \n  RAISE NOTICE 'Creating master job for batch % with % constituent jobs', p_batch_id, array_length(constituent_job_ids, 1);\n  \n  -- Create master job in production_jobs\n  INSERT INTO public.production_jobs (\n    wo_no,\n    customer,\n    status,\n    qty,\n    user_id,\n    batch_category,\n    is_batch_master,\n    created_at,\n    updated_at\n  ) VALUES (\n    batch_record.name || '-MASTER',\n    'Batch Master Job',\n    'Ready to Print',\n    batch_record.sheets_required,\n    batch_record.created_by,\n    'master',\n    true,\n    now(),\n    now()\n  ) RETURNING id INTO master_job_id;\n  \n  RAISE NOTICE 'Created master job with ID: %', master_job_id;\n  \n  -- Update batch status\n  UPDATE public.batches \n  SET status = 'completed', updated_at = now()\n  WHERE id = p_batch_id;\n  \n  RETURN master_job_id;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "create_enhanced_batch_master_job",
    "args": "p_batch_id uuid, p_created_by uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.create_enhanced_batch_master_job(p_batch_id uuid, p_created_by uuid DEFAULT auth.uid())\n RETURNS TABLE(master_job_id uuid, printing_stage_id uuid, constituent_jobs_count integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  batch_record RECORD;\n  master_job_id uuid;\n  printing_stage_id uuid;\n  dominant_category_id uuid;\n  stage_order_num integer;\n  jobs_count integer := 0;\n  earliest_due_date date;\n  stage_record RECORD;\nBEGIN\n  -- Get batch details\n  SELECT b.id, b.name, b.status INTO batch_record\n  FROM public.batches b\n  WHERE b.id = p_batch_id;\n  \n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Batch % not found', p_batch_id;\n  END IF;\n  \n  -- Get constituent jobs count and earliest due date\n  SELECT \n    count(*)::integer,\n    MIN(pj.due_date)\n  INTO jobs_count, earliest_due_date\n  FROM public.batch_job_references bjr\n  JOIN public.production_jobs pj ON bjr.production_job_id = pj.id\n  WHERE bjr.batch_id = p_batch_id;\n  \n  IF jobs_count = 0 THEN\n    RAISE EXCEPTION 'No constituent jobs found for batch %', p_batch_id;\n  END IF;\n  \n  -- Determine dominant category (most common category among constituent jobs)\n  SELECT c.id INTO dominant_category_id\n  FROM public.batch_job_references bjr\n  JOIN public.production_jobs pj ON bjr.production_job_id = pj.id\n  JOIN public.categories c ON pj.category_id = c.id\n  WHERE bjr.batch_id = p_batch_id\n  GROUP BY c.id\n  ORDER BY COUNT(*) DESC\n  LIMIT 1;\n  \n  -- Find appropriate printing stage from dominant category\n  SELECT \n    cps.production_stage_id,\n    cps.stage_order\n  INTO printing_stage_id, stage_order_num\n  FROM public.category_production_stages cps\n  JOIN public.production_stages ps ON cps.production_stage_id = ps.id\n  WHERE cps.category_id = dominant_category_id\n    AND ps.name ILIKE '%print%'\n  ORDER BY cps.stage_order ASC\n  LIMIT 1;\n  \n  IF printing_stage_id IS NULL THEN\n    -- Fallback: find any active printing stage\n    SELECT id INTO printing_stage_id\n    FROM public.production_stages\n    WHERE name ILIKE '%print%' AND is_active = true\n    ORDER BY name\n    LIMIT 1;\n    \n    stage_order_num := 10; -- Default order\n  END IF;\n  \n  IF printing_stage_id IS NULL THEN\n    RAISE EXCEPTION 'No printing stage found for batch processing';\n  END IF;\n  \n  -- Create master job in production_jobs\n  INSERT INTO public.production_jobs (\n    id,\n    user_id,\n    wo_no,\n    status,\n    customer,\n    reference,\n    qty,\n    due_date,\n    category_id,\n    batch_category,\n    is_batch_master,\n    created_at,\n    updated_at\n  ) VALUES (\n    gen_random_uuid(),\n    p_created_by,\n    'BATCH-' || batch_record.name,\n    'In Production',\n    'Batch Processing',\n    'Master job for batch: ' || batch_record.name,\n    jobs_count,\n    earliest_due_date,\n    dominant_category_id,\n    'batch_processing',\n    true,\n    now(),\n    now()\n  ) RETURNING id INTO master_job_id;\n  \n  -- Initialize master job with COMPLETE category workflow - ALL STAGES AS PENDING\n  -- Start from batch allocation stage onwards (skip early stages like DTP and Proof)\n  FOR stage_record IN\n    SELECT \n      cps.production_stage_id,\n      cps.stage_order,\n      ps.name as stage_name\n    FROM public.category_production_stages cps\n    JOIN public.production_stages ps ON cps.production_stage_id = ps.id\n    WHERE cps.category_id = dominant_category_id\n      AND ps.name NOT ILIKE '%dtp%'\n      AND ps.name NOT ILIKE '%proof%'\n      AND ps.name NOT ILIKE '%batch%allocation%'\n    ORDER BY cps.stage_order ASC\n  LOOP\n    INSERT INTO public.job_stage_instances (\n      job_id,\n      job_table_name,\n      category_id,\n      production_stage_id,\n      stage_order,\n      status,\n      started_at,\n      started_by\n    ) VALUES (\n      master_job_id,\n      'production_jobs',\n      dominant_category_id,\n      stage_record.production_stage_id,\n      stage_record.stage_order,\n      'pending', -- ALL stages start as pending - print operator will manually start\n      NULL, -- No auto-start time\n      NULL  -- No auto-s"
  },
  {
    "function_schema": "public",
    "function_name": "expedite_job_factory_wide",
    "args": "p_job_id uuid, p_expedite_reason text, p_expedited_by uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.expedite_job_factory_wide(p_job_id uuid, p_expedite_reason text, p_expedited_by uuid DEFAULT auth.uid())\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Update the production job to mark as expedited\n  UPDATE public.production_jobs\n  SET \n    is_expedited = true,\n    expedited_at = now(),\n    expedited_by = p_expedited_by,\n    expedite_reason = p_expedite_reason,\n    updated_at = now()\n  WHERE id = p_job_id;\n\n  -- Set all current and future stage instances to expedite order (0)\n  UPDATE public.job_stage_instances\n  SET \n    job_order_in_stage = 0,\n    updated_at = now()\n  WHERE job_id = p_job_id \n    AND job_table_name = 'production_jobs';\n\n  RETURN true;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "explain_job_scheduling",
    "args": "p_job_id uuid, p_job_table_name text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.explain_job_scheduling(p_job_id uuid, p_job_table_name text DEFAULT 'production_jobs'::text)\n RETURNS TABLE(stage_name text, scheduled_time text, explanation text, decision_factors jsonb, alternative_options text[])\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    ps.name as stage_name,\n    COALESCE(\n      jsi.auto_scheduled_start_at::text,\n      jsi.scheduled_start_at::text,\n      'Not scheduled'\n    ) as scheduled_time,\n    COALESCE(sdl.decision_reasoning, 'No scheduling decision recorded') as explanation,\n    COALESCE(sdl.decision_factors, '{}'::jsonb) as decision_factors,\n    CASE \n      WHEN sdl.alternative_slots IS NOT NULL AND jsonb_array_length(sdl.alternative_slots) > 0 THEN\n        ARRAY(SELECT jsonb_array_elements_text(sdl.alternative_slots))\n      ELSE\n        ARRAY[]::text[]\n    END as alternative_options\n  FROM public.job_stage_instances jsi\n  JOIN public.production_stages ps ON jsi.production_stage_id = ps.id\n  LEFT JOIN public.scheduling_decision_logs sdl ON (\n    sdl.job_id = jsi.job_id \n    AND sdl.stage_id = jsi.production_stage_id\n    AND sdl.decision_type = 'slot_assignment'\n  )\n  WHERE jsi.job_id = p_job_id \n    AND jsi.job_table_name = p_job_table_name\n  ORDER BY jsi.stage_order;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "export_scheduler_input",
    "args": "",
    "language": "sql",
    "security_definer": false,
    "volatility": "s",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.export_scheduler_input()\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\r\n/*\r\n  Builds JSON for the scheduler.\r\n  - Jobs now include proof_approved_at (non-null for approved jobs).\r\n  - Stages come from v_scheduler_stages_ready (already filtered to approved jobs & pending stages).\r\n*/\r\nwith\r\nmeta as (\r\n  select\r\n    now() at time zone 'utc' as generated_at,\r\n    jsonb_build_array(jsonb_build_object('start_time','13:00:00','minutes',30)) as breaks\r\n),\r\nshifts as (\r\n  select id, day_of_week, shift_start_time, shift_end_time, is_working_day\r\n  from shift_schedules\r\n  where coalesce(is_active, true) = true\r\n),\r\nholidays as (\r\n  select date, name\r\n  from public_holidays\r\n  where coalesce(is_active, true) = true\r\n),\r\n\r\n-- Find the PROOF stage id (fallback to the one you shared earlier)\r\nproof_stage as (\r\n  select coalesce(\r\n    (select id from production_stages where lower(name)='proof' limit 1),\r\n    'ea194968-3604-44a3-9314-d190bb5691c7'::uuid\r\n  ) as id\r\n),\r\n\r\n-- Compute an approval timestamp per job (max of any approval signal)\r\napproved_jobs as (\r\n  select\r\n    jsi.job_id,\r\n    max(\r\n      coalesce(\r\n        jsi.proof_approved_manually_at,\r\n        (select max(pl.responded_at)\r\n           from proof_links pl\r\n          where pl.stage_instance_id = jsi.id\r\n            and lower(coalesce(pl.client_response,'')) in ('approved','accept','accepted')\r\n        ),\r\n        case when jsi.status = 'completed' then jsi.updated_at end\r\n      )\r\n    ) as approved_at\r\n  from job_stage_instances jsi\r\n  join proof_stage ps on ps.id = jsi.production_stage_id\r\n  group by jsi.job_id\r\n),\r\n\r\n-- Jobs that actually have pending stages to schedule (from the view)\r\njobs as (\r\n  select distinct s.job_id\r\n  from public.v_scheduler_stages_ready s\r\n),\r\n\r\njobs_json as (\r\n  select jsonb_agg(\r\n    jsonb_build_object(\r\n      'job_id', j.job_id,\r\n      'wo_number', j.job_id::text,        -- plug in your real WO number later if desired\r\n      'customer_name', '',\r\n      'quantity', 0,\r\n      'due_date', null,\r\n      'proof_approved_at', aj.approved_at,   -- <<< critical: now populated\r\n      'estimated_run_minutes', 0,\r\n      'stages',\r\n        (\r\n          select coalesce(jsonb_agg(\r\n            jsonb_build_object(\r\n              'id',                   s.id,\r\n              'job_id',               s.job_id,\r\n              'status',               s.status,\r\n              'job_table',            s.job_table_name,\r\n              'stage_name',           s.stage_name,\r\n              'stage_group',          s.stage_group,\r\n              'stage_order',\r\n                case\r\n                  when lower(coalesce(s.stage_group,'')) in ('printing','large format') then 10\r\n                  when lower(coalesce(s.stage_group,'')) in ('uv varnishing','laminating','hunkeler','gathering','saddle stitching','finishing') then 20\r\n                  when lower(coalesce(s.stage_group,'')) in ('packaging') then 30\r\n                  when lower(coalesce(s.stage_group,'')) in ('shipping') then 40\r\n                  else 50\r\n                end,\r\n              'setup_minutes',        s.setup_minutes,\r\n              'estimated_minutes',    s.estimated_minutes,\r\n              'scheduled_start_at',   s.scheduled_start_at,\r\n              'scheduled_end_at',     s.scheduled_end_at,\r\n              'scheduled_minutes',    s.scheduled_minutes,\r\n              'schedule_status',      s.schedule_status,\r\n              'production_stage_id',  s.production_stage_id\r\n            )\r\n            order by 4, s.id\r\n          ), '[]'::jsonb)\r\n          from public.v_scheduler_stages_ready s\r\n          where s.job_id = j.job_id\r\n        )\r\n    )\r\n  ) as data\r\n  from jobs j\r\n  left join approved_jobs aj on aj.job_id = j.job_id\r\n)\r\n\r\nselect jsonb_build_object(\r\n  'meta',     (select jsonb_build_object('generated_at', generated_at, 'breaks', breaks) from meta),\r\n  'shifts',   (select coalesce(jsonb_agg(to_jsonb(shifts)   order by day_of_week), '[]'::jsonb) from shifts),"
  },
  {
    "function_schema": "public",
    "function_name": "fix_category_stage_ordering",
    "args": "p_category_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.fix_category_stage_ordering(p_category_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  stage_record RECORD;\n  new_order INTEGER := 1;\n  fixed_count INTEGER := 0;\nBEGIN\n  -- Re-sequence all stages for the category to ensure proper order\n  FOR stage_record IN \n    SELECT id \n    FROM public.category_production_stages \n    WHERE category_id = p_category_id \n    ORDER BY \n      CASE WHEN stage_order < 1 THEN 9999 ELSE stage_order END,\n      created_at\n  LOOP\n    UPDATE public.category_production_stages \n    SET \n      stage_order = new_order, \n      updated_at = now() \n    WHERE id = stage_record.id;\n    \n    new_order := new_order + 1;\n    fixed_count := fixed_count + 1;\n  END LOOP;\n  \n  RETURN jsonb_build_object(\n    'success', true,\n    'fixed_count', fixed_count,\n    'message', format('Fixed ordering for %s stages', fixed_count)\n  );\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "fix_existing_cover_text_workflows",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.fix_existing_cover_text_workflows()\n RETURNS TABLE(fixed_job_id uuid, wo_no text, dependency_group_assigned uuid, stages_updated integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  job_record RECORD;\n  new_dependency_group UUID;\n  updated_stages INTEGER;\n  has_cover BOOLEAN;\n  has_text BOOLEAN;\nBEGIN\n  -- Find jobs with custom workflows that have both cover and text parts but no dependency groups\n  FOR job_record IN\n    SELECT DISTINCT \n      pj.id,\n      pj.wo_no\n    FROM public.production_jobs pj\n    INNER JOIN public.job_stage_instances jsi ON pj.id = jsi.job_id\n    WHERE pj.has_custom_workflow = true\n      AND jsi.job_table_name = 'production_jobs'\n      AND jsi.dependency_group IS NULL\n    GROUP BY pj.id, pj.wo_no\n    HAVING \n      COUNT(CASE WHEN jsi.part_assignment = 'cover' THEN 1 END) > 0 AND\n      COUNT(CASE WHEN jsi.part_assignment = 'text' THEN 1 END) > 0\n  LOOP\n    -- Generate new dependency group for this job\n    new_dependency_group := gen_random_uuid();\n    \n    -- Update stages that should have dependency groups (part_assignment = 'both')\n    UPDATE public.job_stage_instances\n    SET \n      dependency_group = new_dependency_group,\n      updated_at = now()\n    WHERE job_id = job_record.id\n      AND job_table_name = 'production_jobs'\n      AND part_assignment = 'both'\n      AND dependency_group IS NULL;\n    \n    GET DIAGNOSTICS updated_stages = ROW_COUNT;\n    \n    -- Only return if we actually updated stages\n    IF updated_stages > 0 THEN\n      RETURN QUERY SELECT \n        job_record.id,\n        job_record.wo_no,\n        new_dependency_group,\n        updated_stages;\n    END IF;\n  END LOOP;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_admin_status",
    "args": "check_user_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_admin_status(check_user_id uuid DEFAULT NULL::uuid)\n RETURNS TABLE(user_is_admin boolean, any_admin_exists boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  RETURN QUERY SELECT \n    CASE \n      WHEN check_user_id IS NOT NULL THEN \n        EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = check_user_id AND role = 'admin')\n      ELSE false\n    END as user_is_admin,\n    EXISTS (SELECT 1 FROM public.user_roles WHERE role = 'admin') as any_admin_exists;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_admin_user_stats",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_admin_user_stats()\n RETURNS TABLE(total_users integer, admin_users integer, regular_users integer, users_without_profiles integer, recent_signups integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  -- Check if the current user is an admin\n  IF NOT EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin') THEN\n    RAISE EXCEPTION 'Admin access required';\n  END IF;\n  \n  RETURN QUERY \n  SELECT \n    (SELECT COUNT(*)::integer FROM auth.users)::integer as total_users,\n    (SELECT COUNT(*)::integer FROM public.user_roles WHERE role = 'admin')::integer as admin_users,\n    (SELECT COUNT(*)::integer FROM public.user_roles WHERE role = 'user' OR role IS NULL)::integer as regular_users,\n    (SELECT COUNT(*)::integer FROM auth.users au LEFT JOIN public.profiles p ON au.id = p.id WHERE p.id IS NULL)::integer as users_without_profiles,\n    (SELECT COUNT(*)::integer FROM auth.users WHERE created_at >= now() - interval '7 days')::integer as recent_signups;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_all_users",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_all_users()\n RETURNS TABLE(id uuid, email text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  -- Simply return empty set - admin functionality is removed\n  RETURN QUERY SELECT NULL::uuid, NULL::text WHERE false;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_all_users_secure",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_all_users_secure()\n RETURNS TABLE(id uuid, email text)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  -- Check if the current user is an admin\n  IF EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin') THEN\n    -- Return all users from auth.users table\n    RETURN QUERY \n    SELECT au.id, au.email::text \n    FROM auth.users au\n    WHERE au.email IS NOT NULL;\n  ELSE\n    -- Return empty set if not admin\n    RETURN QUERY SELECT NULL::uuid, NULL::text WHERE false;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_all_users_with_complete_data",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_all_users_with_complete_data()\n RETURNS TABLE(id uuid, email text, full_name text, avatar_url text, role text, created_at timestamp with time zone, last_sign_in_at timestamp with time zone, email_confirmed_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  -- Check if the current user is an admin\n  IF EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin') THEN\n    RETURN QUERY \n    SELECT \n      au.id,\n      au.email::text,\n      COALESCE(p.full_name, au.email::text) as full_name,\n      p.avatar_url,\n      COALESCE(ur.role, 'user') as role,\n      au.created_at,\n      au.last_sign_in_at,\n      au.email_confirmed_at\n    FROM auth.users au\n    LEFT JOIN public.profiles p ON au.id = p.id\n    LEFT JOIN public.user_roles ur ON au.id = ur.user_id\n    WHERE au.email IS NOT NULL\n    ORDER BY au.created_at DESC;\n  ELSE\n    -- Return empty set if not admin\n    RETURN QUERY SELECT \n      NULL::uuid, \n      NULL::text, \n      NULL::text, \n      NULL::text, \n      NULL::text, \n      NULL::timestamptz, \n      NULL::timestamptz, \n      NULL::timestamptz \n    WHERE false;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_all_users_with_roles",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_all_users_with_roles()\n RETURNS TABLE(id uuid, email text, full_name text, avatar_url text, role text, created_at timestamp with time zone, last_sign_in_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  -- Return empty set since admin functionality is removed\n  RETURN QUERY SELECT \n    NULL::uuid, \n    NULL::text,\n    NULL::text,\n    NULL::text,\n    NULL::text,\n    NULL::timestamptz,\n    NULL::timestamptz\n  WHERE false;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_available_stages_for_activation",
    "args": "p_job_id uuid, p_job_table_name text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_available_stages_for_activation(p_job_id uuid, p_job_table_name text)\n RETURNS TABLE(stage_id uuid, stage_name text, stage_order integer, part_assignment text, can_activate boolean, blocking_reason text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    jsi.id as stage_id,\n    ps.name as stage_name,\n    jsi.stage_order,\n    jsi.part_assignment,\n    CASE \n      WHEN jsi.status != 'pending' THEN false\n      WHEN EXISTS (\n        SELECT 1 FROM public.job_stage_instances prev_jsi\n        WHERE prev_jsi.job_id = p_job_id \n          AND prev_jsi.job_table_name = p_job_table_name\n          AND prev_jsi.stage_order < jsi.stage_order\n          AND prev_jsi.status NOT IN ('completed', 'skipped')\n      ) THEN false\n      ELSE true\n    END as can_activate,\n    CASE \n      WHEN jsi.status != 'pending' THEN 'Stage is ' || jsi.status\n      WHEN EXISTS (\n        SELECT 1 FROM public.job_stage_instances prev_jsi\n        WHERE prev_jsi.job_id = p_job_id \n          AND prev_jsi.job_table_name = p_job_table_name\n          AND prev_jsi.stage_order < jsi.stage_order\n          AND prev_jsi.status NOT IN ('completed', 'skipped')\n      ) THEN 'Previous stages must be completed first'\n      ELSE 'Ready to start'\n    END as blocking_reason\n  FROM public.job_stage_instances jsi\n  JOIN public.production_stages ps ON jsi.production_stage_id = ps.id\n  WHERE jsi.job_id = p_job_id \n    AND jsi.job_table_name = p_job_table_name\n  ORDER BY jsi.stage_order;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_category_usage_stats",
    "args": "p_category_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_category_usage_stats(p_category_id uuid)\n RETURNS TABLE(production_jobs_count integer, job_stage_instances_count integer, category_production_stages_count integer, can_delete boolean, blocking_reason text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  prod_jobs_count integer := 0;\n  stage_instances_count integer := 0;\n  cat_stages_count integer := 0;\nBEGIN\n  -- Count production jobs using this category\n  SELECT COUNT(*)::integer INTO prod_jobs_count\n  FROM public.production_jobs\n  WHERE category_id = p_category_id;\n  \n  -- Count job stage instances using this category\n  SELECT COUNT(*)::integer INTO stage_instances_count\n  FROM public.job_stage_instances\n  WHERE category_id = p_category_id;\n  \n  -- Count category production stages\n  SELECT COUNT(*)::integer INTO cat_stages_count\n  FROM public.category_production_stages\n  WHERE category_id = p_category_id;\n  \n  RETURN QUERY SELECT \n    prod_jobs_count,\n    stage_instances_count,\n    cat_stages_count,\n    CASE \n      WHEN prod_jobs_count = 0 AND stage_instances_count = 0 THEN true\n      ELSE false\n    END as can_delete,\n    CASE \n      WHEN prod_jobs_count > 0 THEN format('Category is used by %s production job(s)', prod_jobs_count)\n      WHEN stage_instances_count > 0 THEN format('Category has %s active workflow stage(s)', stage_instances_count)\n      ELSE 'Category can be safely deleted'\n    END as blocking_reason;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_compatible_specifications",
    "args": "p_product_type text, p_category text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_compatible_specifications(p_product_type text, p_category text)\n RETURNS TABLE(id uuid, name text, display_name text, description text, properties jsonb, is_default boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    ps.id,\n    ps.name,\n    ps.display_name,\n    ps.description,\n    ps.properties,\n    COALESCE(psc.is_default, false) as is_default\n  FROM public.print_specifications ps\n  LEFT JOIN public.product_specification_compatibility psc ON (\n    ps.id = psc.specification_id \n    AND psc.product_type = p_product_type\n  )\n  WHERE ps.category = p_category\n    AND ps.is_active = true\n    AND ps.name != '_category' -- Exclude category headers\n    AND (psc.is_compatible IS NULL OR psc.is_compatible = true)\n  ORDER BY ps.sort_order, ps.display_name;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_department_job_queue",
    "args": "p_department_id uuid",
    "language": "sql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_department_job_queue(p_department_id uuid)\n RETURNS TABLE(job_id uuid, job_table_name text, wo_no text, customer text, due_date date, status text, priority_order integer, has_priority_override boolean, current_stage text, is_blocked boolean)\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n  WITH job_priorities AS (\n    SELECT \n      pj.id as job_id,\n      'production_jobs' as job_table_name,\n      pj.wo_no,\n      pj.customer,\n      pj.due_date,\n      pj.status,\n      COALESCE(jpo.priority_order, \n        ROW_NUMBER() OVER (ORDER BY pj.wo_no)::INTEGER\n      ) as priority_order,\n      jpo.id IS NOT NULL as has_priority_override,\n      -- Get current stage from job_stage_instances\n      (SELECT ps.name \n       FROM public.job_stage_instances jsi \n       JOIN public.production_stages ps ON jsi.production_stage_id = ps.id\n       WHERE jsi.job_id = pj.id \n         AND jsi.job_table_name = 'production_jobs' \n         AND jsi.status = 'active'\n       LIMIT 1\n      ) as current_stage,\n      -- Check if job is blocked (previous job not complete for non-concurrent departments)\n      false as is_blocked -- Will be calculated in application logic\n    FROM public.production_jobs pj\n    LEFT JOIN public.job_priority_overrides jpo ON (\n      jpo.job_id = pj.id \n      AND jpo.job_table_name = 'production_jobs'\n      AND jpo.department_id = p_department_id\n    )\n    WHERE pj.status != 'completed'\n  )\n  SELECT * FROM job_priorities\n  ORDER BY priority_order;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_job_rework_history",
    "args": "p_job_id uuid, p_job_table_name text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_job_rework_history(p_job_id uuid, p_job_table_name text)\n RETURNS TABLE(stage_name text, rework_count integer, last_rework_reason text, total_reworks bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    ps.name as stage_name,\n    jsi.rework_count,\n    jsi.rework_reason as last_rework_reason,\n    COUNT(*) FILTER (WHERE jsi.is_rework = true) as total_reworks\n  FROM public.job_stage_instances jsi\n  JOIN public.production_stages ps ON jsi.production_stage_id = ps.id\n  WHERE jsi.job_id = p_job_id \n    AND jsi.job_table_name = p_job_table_name\n    AND jsi.rework_count > 0\n  GROUP BY ps.name, jsi.rework_count, jsi.rework_reason\n  ORDER BY jsi.stage_order;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_job_specifications",
    "args": "p_job_id uuid, p_job_table_name text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_job_specifications(p_job_id uuid, p_job_table_name text)\n RETURNS TABLE(category text, specification_id uuid, name text, display_name text, properties jsonb, printer_id uuid, printer_name text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    jps.specification_category,\n    jps.specification_id,\n    ps.name,\n    ps.display_name,\n    ps.properties,\n    jps.printer_id,\n    p.name as printer_name\n  FROM public.job_print_specifications jps\n  JOIN public.print_specifications ps ON jps.specification_id = ps.id\n  LEFT JOIN public.printers p ON jps.printer_id = p.id\n  WHERE jps.job_id = p_job_id \n    AND jps.job_table_name = p_job_table_name;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_next_active_stage",
    "args": "p_job_id uuid, p_job_table_name text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_next_active_stage(p_job_id uuid, p_job_table_name text)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  next_stage_id UUID;\nBEGIN\n  -- Get the next pending stage in order\n  SELECT production_stage_id INTO next_stage_id\n  FROM public.job_stage_instances\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND status = 'pending'\n  ORDER BY stage_order ASC\n  LIMIT 1;\n  \n  RETURN next_stage_id;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_next_capacity_slot",
    "args": "p_stage_id uuid, p_duration_minutes integer, p_earliest_date date",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_next_capacity_slot(p_stage_id uuid, p_duration_minutes integer, p_earliest_date date DEFAULT CURRENT_DATE)\n RETURNS TABLE(start_time timestamp with time zone, end_time timestamp with time zone, date_scheduled date)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  stage_capacity_hours integer := 8; -- Default 8 hours daily capacity\n  check_date date;\n  used_minutes integer;\n  available_minutes integer;\n  slot_start_time timestamp with time zone;\n  slot_end_time timestamp with time zone;\nBEGIN\n  -- Get stage capacity from profile\n  SELECT daily_capacity_hours INTO stage_capacity_hours\n  FROM public.stage_capacity_profiles \n  WHERE production_stage_id = p_stage_id;\n  \n  -- Default to 8 hours if no profile found\n  stage_capacity_hours := COALESCE(stage_capacity_hours, 8);\n  \n  -- Start checking from earliest date\n  check_date := p_earliest_date;\n  \n  -- Loop through working days to find available capacity\n  FOR i IN 0..90 LOOP -- Max 90 day search window\n    -- Skip weekends\n    IF EXTRACT(dow FROM check_date) NOT IN (0, 6) THEN\n      \n      -- Calculate used capacity for this stage on this date\n      SELECT COALESCE(SUM(\n        CASE \n          WHEN auto_scheduled_duration_minutes IS NOT NULL THEN auto_scheduled_duration_minutes\n          ELSE scheduled_minutes\n        END\n      ), 0) INTO used_minutes\n      FROM public.job_stage_instances jsi\n      WHERE jsi.production_stage_id = p_stage_id\n        AND jsi.status IN ('pending', 'active')\n        AND (\n          (jsi.auto_scheduled_start_at IS NOT NULL AND \n           DATE(jsi.auto_scheduled_start_at AT TIME ZONE 'Africa/Johannesburg') = check_date) OR\n          (jsi.scheduled_start_at IS NOT NULL AND \n           DATE(jsi.scheduled_start_at AT TIME ZONE 'Africa/Johannesburg') = check_date)\n        );\n      \n      -- Calculate available capacity\n      available_minutes := (stage_capacity_hours * 60) - used_minutes;\n      \n      -- Check if this date has enough capacity\n      IF available_minutes >= p_duration_minutes THEN\n        -- Found a slot! Calculate start time (8 AM SAST + used time)\n        slot_start_time := (check_date::timestamp + INTERVAL '8 hours') + (used_minutes || ' minutes')::INTERVAL;\n        slot_end_time := slot_start_time + (p_duration_minutes || ' minutes')::INTERVAL;\n        \n        -- Ensure slot doesn't exceed working hours (8 AM - 5:30 PM = 9.5 hours)\n        IF EXTRACT(hour FROM slot_end_time) <= 17 OR \n           (EXTRACT(hour FROM slot_end_time) = 17 AND EXTRACT(minute FROM slot_end_time) <= 30) THEN\n          \n          RETURN QUERY SELECT slot_start_time, slot_end_time, check_date;\n          RETURN;\n        END IF;\n      END IF;\n    END IF;\n    \n    -- Move to next day\n    check_date := check_date + INTERVAL '1 day';\n  END LOOP;\n  \n  -- No capacity found in 90 days - return null\n  RETURN;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_user_accessible_jobs",
    "args": "p_user_id uuid, p_permission_type text, p_status_filter text, p_stage_filter uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_user_accessible_jobs(p_user_id uuid DEFAULT auth.uid(), p_permission_type text DEFAULT 'work'::text, p_status_filter text DEFAULT NULL::text, p_stage_filter uuid DEFAULT NULL::uuid)\n RETURNS TABLE(job_id uuid, wo_no text, customer text, status text, due_date text, reference text, category_id uuid, category_name text, category_color text, current_stage_id uuid, current_stage_name text, current_stage_color text, current_stage_status text, user_can_view boolean, user_can_edit boolean, user_can_work boolean, user_can_manage boolean, workflow_progress integer, total_stages integer, completed_stages integer, display_stage_name text, qty integer, started_by uuid, started_by_name text, proof_emailed_at text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Check if user is admin - admins get all data\n  IF EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = p_user_id AND role = 'admin') THEN\n    RETURN QUERY\n    WITH job_stage_counts AS (\n      SELECT \n        jsi.job_id,\n        COUNT(*)::integer as total_stages,\n        COUNT(CASE WHEN jsi.status = 'completed' THEN 1 END)::integer as completed_stages\n      FROM public.job_stage_instances jsi\n      WHERE jsi.job_table_name = 'production_jobs'\n      GROUP BY jsi.job_id\n    ),\n    job_current_stages AS (\n      SELECT DISTINCT ON (jsi.job_id)\n        jsi.job_id,\n        jsi.production_stage_id as current_stage_id,\n        jsi.status as current_stage_status,\n        jsi.category_id,\n        jsi.started_by,\n        jsi.proof_emailed_at\n      FROM public.job_stage_instances jsi\n      WHERE jsi.job_table_name = 'production_jobs'\n        AND jsi.status IN ('active', 'pending')\n      ORDER BY jsi.job_id, \n               CASE WHEN jsi.status = 'active' THEN 0 ELSE 1 END,\n               jsi.stage_order ASC\n    )\n    SELECT \n      pj.id::uuid as job_id,\n      COALESCE(pj.wo_no, '')::text,\n      COALESCE(pj.customer, 'Unknown')::text as customer,\n      COALESCE(pj.status, 'Unknown')::text as status,\n      COALESCE(pj.due_date::text, '')::text as due_date,\n      COALESCE(pj.reference, '')::text as reference,\n      COALESCE(pj.category_id, '00000000-0000-0000-0000-000000000000'::uuid)::uuid,\n      COALESCE(c.name, 'No Category')::text as category_name,\n      COALESCE(c.color, '#6B7280')::text as category_color,\n      COALESCE(jcs.current_stage_id, '00000000-0000-0000-0000-000000000000'::uuid)::uuid,\n      COALESCE(ps.name, 'No Stage')::text as current_stage_name,\n      COALESCE(ps.color, '#6B7280')::text as current_stage_color,\n      COALESCE(jcs.current_stage_status, 'pending')::text,\n      true::boolean as user_can_view,\n      true::boolean as user_can_edit,\n      true::boolean as user_can_work,\n      true::boolean as user_can_manage,\n      CASE \n        WHEN COALESCE(jsc.total_stages, 0) > 0 THEN \n          ROUND((COALESCE(jsc.completed_stages, 0)::float / jsc.total_stages::float) * 100)::integer\n        ELSE 0 \n      END::integer as workflow_progress,\n      COALESCE(jsc.total_stages, 0)::integer as total_stages,\n      COALESCE(jsc.completed_stages, 0)::integer as completed_stages,\n      COALESCE(ps.name, 'No Stage')::text as display_stage_name,\n      COALESCE(pj.qty, 0)::integer as qty,\n      jcs.started_by::uuid,\n      COALESCE(p.full_name, 'Unknown')::text as started_by_name,\n      COALESCE(jcs.proof_emailed_at::text, '')::text as proof_emailed_at\n    FROM public.production_jobs pj\n    LEFT JOIN job_current_stages jcs ON pj.id = jcs.job_id  \n    LEFT JOIN job_stage_counts jsc ON pj.id = jsc.job_id\n    LEFT JOIN public.production_stages ps ON jcs.current_stage_id = ps.id\n    LEFT JOIN public.categories c ON pj.category_id = c.id\n    LEFT JOIN public.profiles p ON jcs.started_by = p.id\n    WHERE \n      (p_status_filter = 'completed' OR (p_status_filter IS NULL AND pj.status != 'Completed') OR (p_status_filter IS NOT NULL AND p_status_filter != 'completed' AND pj.status = p_status_filter))\n      AND (p_stage_filter IS NULL OR jcs.current_stage"
  },
  {
    "function_schema": "public",
    "function_name": "get_user_accessible_jobs_with_batch_allocation",
    "args": "p_user_id uuid, p_permission_type text, p_status_filter text, p_stage_filter text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_user_accessible_jobs_with_batch_allocation(p_user_id uuid DEFAULT auth.uid(), p_permission_type text DEFAULT 'work'::text, p_status_filter text DEFAULT NULL::text, p_stage_filter text DEFAULT NULL::text)\n RETURNS TABLE(job_id uuid, wo_no text, customer text, status text, due_date text, reference text, category_id uuid, category_name text, category_color text, current_stage_id uuid, current_stage_name text, current_stage_color text, current_stage_status text, display_stage_name text, user_can_view boolean, user_can_edit boolean, user_can_work boolean, user_can_manage boolean, workflow_progress integer, total_stages integer, completed_stages integer, qty integer, started_by uuid, started_by_name text, proof_emailed_at text, has_custom_workflow boolean, manual_due_date date, manual_sla_days integer, categories jsonb, sla_target_days integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Enhanced query that handles concurrent stages and master queue consolidation\n  RETURN QUERY\n  WITH job_stage_counts AS (\n    SELECT \n      jsi.job_id,\n      COUNT(DISTINCT COALESCE(ps.master_queue_id, jsi.production_stage_id))::integer as total_stages,\n      COUNT(DISTINCT CASE WHEN jsi.status = 'completed' THEN COALESCE(ps.master_queue_id, jsi.production_stage_id) END)::integer as completed_stages\n    FROM public.job_stage_instances jsi\n    JOIN public.production_stages ps ON jsi.production_stage_id = ps.id\n    WHERE jsi.job_table_name = 'production_jobs'\n    GROUP BY jsi.job_id\n  ),\n  job_current_stages AS (\n    SELECT DISTINCT ON (jsi.job_id)\n      jsi.job_id,\n      COALESCE(mq.id, jsi.production_stage_id) as current_stage_id,\n      COALESCE(mq.name, ps.name) as current_stage_name,\n      COALESCE(mq.color, ps.color) as current_stage_color,\n      jsi.status as current_stage_status,\n      jsi.category_id,\n      jsi.started_by,\n      jsi.proof_emailed_at,\n      -- Enhanced display name for concurrent stages\n      CASE \n        WHEN jsi.concurrent_stage_group_id IS NOT NULL THEN \n          COALESCE(mq.name, ps.name) || ' (Multi-Part)'\n        ELSE \n          COALESCE(mq.name, ps.name)\n      END as display_stage_name\n    FROM public.job_stage_instances jsi\n    JOIN public.production_stages ps ON jsi.production_stage_id = ps.id\n    LEFT JOIN public.production_stages mq ON ps.master_queue_id = mq.id\n    WHERE jsi.job_table_name = 'production_jobs'\n      AND jsi.status IN ('active', 'pending')\n    ORDER BY jsi.job_id, jsi.stage_order ASC\n  )\n  SELECT \n    pj.id::UUID as job_id,\n    COALESCE(pj.wo_no, '')::TEXT,\n    COALESCE(pj.customer, 'Unknown')::TEXT as customer,\n    COALESCE(pj.status, 'Unknown')::TEXT as status,\n    COALESCE(pj.due_date::TEXT, '')::TEXT as due_date,\n    COALESCE(pj.reference, '')::TEXT as reference,\n    COALESCE(pj.category_id, '00000000-0000-0000-0000-000000000000'::UUID)::UUID,\n    COALESCE(c.name, 'No Category')::TEXT as category_name,\n    COALESCE(c.color, '#6B7280')::TEXT as category_color,\n    COALESCE(jcs.current_stage_id, '00000000-0000-0000-0000-000000000000'::UUID)::UUID,\n    COALESCE(jcs.current_stage_name, 'No Stage')::TEXT as current_stage_name,\n    COALESCE(jcs.current_stage_color, '#6B7280')::TEXT as current_stage_color,\n    COALESCE(jcs.current_stage_status, 'pending')::TEXT,\n    COALESCE(jcs.display_stage_name, jcs.current_stage_name, 'No Stage')::TEXT,\n    true::BOOLEAN as user_can_view,\n    true::BOOLEAN as user_can_edit, \n    true::BOOLEAN as user_can_work,\n    true::BOOLEAN as user_can_manage,\n    CASE \n      WHEN COALESCE(jsc.total_stages, 0) > 0 THEN \n        ROUND((COALESCE(jsc.completed_stages, 0)::float / jsc.total_stages::float) * 100)::integer\n      ELSE 0 \n    END::integer as workflow_progress,\n    COALESCE(jsc.total_stages, 0)::integer as total_stages,\n    COALESCE(jsc.completed_stages, 0)::integer as completed_stages,\n    COALESCE(pj.qty, 0)::integer as qty,\n    jcs.started_by::UUID,\n    ''::TEXT as started_by_name,\n    COALESCE(jcs.proof_emailed_a"
  },
  {
    "function_schema": "public",
    "function_name": "get_user_accessible_stages",
    "args": "p_user_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_user_accessible_stages(p_user_id uuid DEFAULT auth.uid())\n RETURNS TABLE(stage_id uuid, stage_name text, stage_color text, can_view boolean, can_edit boolean, can_work boolean, can_manage boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    ps.id as stage_id,\n    ps.name as stage_name,\n    ps.color as stage_color,\n    BOOL_OR(ugsp.can_view) as can_view,\n    BOOL_OR(ugsp.can_edit) as can_edit,\n    BOOL_OR(ugsp.can_work) as can_work,\n    BOOL_OR(ugsp.can_manage) as can_manage\n  FROM public.production_stages ps\n  INNER JOIN public.user_group_stage_permissions ugsp ON ps.id = ugsp.production_stage_id\n  INNER JOIN public.user_group_memberships ugm ON ugsp.user_group_id = ugm.group_id\n  WHERE ugm.user_id = p_user_id\n    AND ps.is_active = true\n  GROUP BY ps.id, ps.name, ps.color, ps.order_index\n  ORDER BY ps.order_index;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_user_accessible_stages_with_master_queue",
    "args": "p_user_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_user_accessible_stages_with_master_queue(p_user_id uuid DEFAULT auth.uid())\n RETURNS TABLE(stage_id uuid, stage_name text, stage_color text, can_view boolean, can_edit boolean, can_work boolean, can_manage boolean, master_queue_id uuid, master_queue_name text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    ps.id as stage_id,\n    ps.name as stage_name,\n    ps.color as stage_color,\n    BOOL_OR(ugsp.can_view) as can_view,\n    BOOL_OR(ugsp.can_edit) as can_edit,\n    BOOL_OR(ugsp.can_work) as can_work,\n    BOOL_OR(ugsp.can_manage) as can_manage,\n    ps.master_queue_id,\n    mq.name as master_queue_name\n  FROM public.production_stages ps\n  INNER JOIN public.user_group_stage_permissions ugsp ON ps.id = ugsp.production_stage_id\n  INNER JOIN public.user_group_memberships ugm ON ugsp.user_group_id = ugm.group_id\n  LEFT JOIN public.production_stages mq ON ps.master_queue_id = mq.id\n  WHERE ugm.user_id = p_user_id\n    AND ps.is_active = true\n  GROUP BY ps.id, ps.name, ps.color, ps.order_index, ps.master_queue_id, mq.name\n  ORDER BY ps.order_index;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_user_departments",
    "args": "p_user_id uuid",
    "language": "sql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_user_departments(p_user_id uuid DEFAULT auth.uid())\n RETURNS TABLE(department_id uuid, department_name text, department_color text, allows_concurrent_jobs boolean, max_concurrent_jobs integer)\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n  SELECT \n    d.id,\n    d.name,\n    d.color,\n    d.allows_concurrent_jobs,\n    d.max_concurrent_jobs\n  FROM public.departments d\n  JOIN public.user_department_assignments uda ON d.id = uda.department_id\n  WHERE uda.user_id = p_user_id;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "get_user_role_safe",
    "args": "user_id_param uuid",
    "language": "sql",
    "security_definer": true,
    "volatility": "s",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.get_user_role_safe(user_id_param uuid)\n RETURNS text\n LANGUAGE sql\n STABLE SECURITY DEFINER\nAS $function$\n  SELECT role FROM public.user_roles WHERE user_id = user_id_param LIMIT 1;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "handle_new_user",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  -- Extract full_name from user metadata and create profile\n  INSERT INTO public.profiles (id, full_name)\n  VALUES (\n    new.id, \n    CASE \n      WHEN new.raw_user_meta_data->>'full_name' IS NOT NULL THEN\n        new.raw_user_meta_data->>'full_name'\n      ELSE\n        NULL\n    END\n  );\n  \n  -- Create default user role with proper column\n  INSERT INTO public.user_roles (user_id, role)\n  VALUES (new.id, 'user');\n  \n  RETURN new;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "initialize_custom_job_stages",
    "args": "p_job_id uuid, p_job_table_name text, p_stage_ids uuid[], p_stage_orders integer[]",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.initialize_custom_job_stages(p_job_id uuid, p_job_table_name text, p_stage_ids uuid[], p_stage_orders integer[])\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  stage_id uuid;\n  stage_order integer;\n  first_stage BOOLEAN := TRUE;\n  i integer;\nBEGIN\n  -- Validate input arrays have same length\n  IF array_length(p_stage_ids, 1) != array_length(p_stage_orders, 1) THEN\n    RAISE EXCEPTION 'Stage IDs and orders arrays must have the same length';\n  END IF;\n\n  -- Create stage instances for each selected stage\n  FOR i IN 1..array_length(p_stage_ids, 1) LOOP\n    stage_id := p_stage_ids[i];\n    stage_order := p_stage_orders[i];\n    \n    INSERT INTO public.job_stage_instances (\n      job_id,\n      job_table_name,\n      category_id,\n      production_stage_id,\n      stage_order,\n      status,\n      started_at,\n      started_by\n    ) VALUES (\n      p_job_id,\n      p_job_table_name,\n      NULL, -- No category for custom workflows\n      stage_id,\n      stage_order,\n      CASE WHEN first_stage THEN 'active' ELSE 'pending' END,\n      CASE WHEN first_stage THEN now() ELSE NULL END,\n      CASE WHEN first_stage THEN auth.uid() ELSE NULL END\n    );\n    \n    first_stage := FALSE;\n  END LOOP;\n  \n  -- Mark the job as having a custom workflow\n  EXECUTE format('UPDATE %I SET has_custom_workflow = TRUE, updated_at = now() WHERE id = $1', p_job_table_name)\n  USING p_job_id;\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "initialize_custom_job_stages_with_specs",
    "args": "p_job_id uuid, p_job_table_name text, p_category_id uuid, p_part_assignments jsonb",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.initialize_custom_job_stages_with_specs(p_job_id uuid, p_job_table_name text, p_category_id uuid, p_part_assignments jsonb DEFAULT '{}'::jsonb)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  stage_record RECORD;\n  part_assignment_value text;\n  dependency_group_id uuid;\n  stage_name text;\n  should_have_dependency boolean;\nBEGIN\n  -- Generate a dependency group ID for this job's synchronization stages\n  dependency_group_id := gen_random_uuid();\n  \n  -- Create stage instances for each stage in the category\n  FOR stage_record IN\n    SELECT \n      cps.production_stage_id,\n      cps.stage_order,\n      cps.estimated_duration_hours,\n      ps.name as stage_name,\n      ps.running_speed_per_hour,\n      ps.make_ready_time_minutes,\n      ps.speed_unit\n    FROM public.category_production_stages cps\n    JOIN public.production_stages ps ON cps.production_stage_id = ps.id\n    WHERE cps.category_id = p_category_id\n      AND ps.is_active = true\n    ORDER BY cps.stage_order ASC\n  LOOP\n    stage_name := stage_record.stage_name;\n    \n    -- Get part assignment from the provided assignments\n    part_assignment_value := COALESCE(\n      p_part_assignments->>stage_record.production_stage_id::text, \n      'both'\n    );\n    \n    -- Determine if this stage should wait for dependencies (TRUE synchronization stages only)\n    -- These are stages where cover and text parts come together\n    should_have_dependency := (\n      stage_name ILIKE '%Perfect Binding%' OR\n      stage_name ILIKE '%Saddle Stitching%' OR\n      stage_name ILIKE '%Collating%' OR\n      stage_name ILIKE '%Assembly%' OR\n      stage_name ILIKE '%Binding%' OR\n      stage_name ILIKE '%Final Assembly%' OR\n      stage_name ILIKE '%Quality Check%' OR\n      stage_name ILIKE '%Packing%' OR\n      stage_name ILIKE '%Dispatch%' OR\n      stage_name ILIKE '%Gathering%' OR\n      stage_name ILIKE '%Collection%' OR\n      stage_name ILIKE '%Delivery%' OR\n      stage_name ILIKE '%Final Trimming%' OR\n      stage_name ILIKE '%Inspection%' OR\n      stage_name ILIKE '%Packaging%'\n    );\n    \n    -- Part-specific finishing stages should NOT have dependency groups:\n    -- Hunkeler (text-specific), UV Varnishing (cover-specific), etc.\n    \n    INSERT INTO public.job_stage_instances (\n      job_id,\n      job_table_name,\n      category_id,\n      production_stage_id,\n      stage_order,\n      status,\n      part_assignment,\n      quantity,\n      estimated_duration_minutes,\n      setup_time_minutes,\n      dependency_group\n    ) VALUES (\n      p_job_id,\n      p_job_table_name,\n      p_category_id,\n      stage_record.production_stage_id,\n      stage_record.stage_order,\n      'pending',\n      part_assignment_value,\n      NULL, -- Will be set later when quantities are assigned\n      NULL, -- Will be calculated when quantities are assigned\n      COALESCE(stage_record.make_ready_time_minutes, 10),\n      CASE WHEN should_have_dependency THEN dependency_group_id ELSE NULL END\n    );\n  END LOOP;\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "initialize_custom_job_stages_with_specs",
    "args": "p_job_id uuid, p_job_table_name text, p_stage_mappings jsonb",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.initialize_custom_job_stages_with_specs(p_job_id uuid, p_job_table_name text, p_stage_mappings jsonb)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  stage_mapping RECORD;\n  stage_counter INTEGER := 1;\n  has_cover_parts BOOLEAN := false;\n  has_text_parts BOOLEAN := false;\n  dependency_group_id UUID := NULL;\n  current_part_assignment TEXT;\n  stage_supports_parts BOOLEAN;\nBEGIN\n  -- Validate input parameters\n  IF p_job_id IS NULL OR p_job_table_name IS NULL THEN\n    RAISE EXCEPTION 'job_id and job_table_name must be provided';\n  END IF;\n\n  IF p_stage_mappings IS NULL OR jsonb_array_length(p_stage_mappings) = 0 THEN\n    RAISE EXCEPTION 'stage_mappings must be provided and non-empty';\n  END IF;\n\n  -- First pass: detect if this is a cover/text workflow\n  FOR stage_mapping IN\n    SELECT \n      value->>'part_name' as part_name\n    FROM jsonb_array_elements(p_stage_mappings)\n  LOOP\n    IF stage_mapping.part_name ILIKE '%cover%' THEN\n      has_cover_parts := true;\n    END IF;\n    \n    IF stage_mapping.part_name ILIKE '%text%' THEN\n      has_text_parts := true;\n    END IF;\n  END LOOP;\n\n  -- Generate dependency group if both cover and text parts are present\n  IF has_cover_parts AND has_text_parts THEN\n    dependency_group_id := gen_random_uuid();\n    RAISE LOG 'Cover/Text workflow detected for job %, creating dependency group: %', p_job_id, dependency_group_id;\n  END IF;\n\n  -- Second pass: create stage instances with proper dependency groups based on supports_parts\n  FOR stage_mapping IN\n    SELECT \n      (value->>'stage_id')::uuid as stage_id,\n      value->>'unique_stage_id' as unique_stage_id,\n      (value->>'stage_order')::integer as stage_order,\n      (value->>'stage_specification_id')::uuid as stage_specification_id,\n      value->>'part_name' as part_name,\n      (value->>'quantity')::integer as quantity,\n      value->>'paper_specification' as paper_specification\n    FROM jsonb_array_elements(p_stage_mappings)\n    ORDER BY (value->>'stage_order')::integer\n  LOOP\n    -- Get the supports_parts flag from the production_stages table\n    SELECT ps.supports_parts INTO stage_supports_parts\n    FROM public.production_stages ps\n    WHERE ps.id = stage_mapping.stage_id;\n    \n    -- Determine part assignment based on part_name\n    IF stage_mapping.part_name ILIKE '%cover%' THEN\n      current_part_assignment := 'cover';\n    ELSIF stage_mapping.part_name ILIKE '%text%' THEN\n      current_part_assignment := 'text';\n    ELSE\n      current_part_assignment := 'both';\n    END IF;\n\n    INSERT INTO public.job_stage_instances (\n      job_id,\n      job_table_name,\n      category_id,\n      production_stage_id,\n      stage_order,\n      stage_specification_id,\n      part_name,\n      part_assignment,\n      quantity,\n      status,\n      dependency_group,\n      notes,\n      unique_stage_key\n    ) VALUES (\n      p_job_id,\n      p_job_table_name,\n      NULL, -- No category for custom workflows with specifications\n      stage_mapping.stage_id,\n      stage_mapping.stage_order,\n      stage_mapping.stage_specification_id,\n      stage_mapping.part_name,\n      current_part_assignment,\n      stage_mapping.quantity,\n      'pending', -- All stages start as pending\n      CASE \n        WHEN dependency_group_id IS NOT NULL AND NOT COALESCE(stage_supports_parts, false) THEN dependency_group_id\n        ELSE NULL\n      END,\n      CASE \n        WHEN stage_mapping.paper_specification IS NOT NULL THEN \n          'Paper: ' || stage_mapping.paper_specification\n        ELSE NULL \n      END,\n      -- Generate unique key using job_id, stage counter, and unique_stage_id to prevent collisions\n      COALESCE(stage_mapping.unique_stage_id, p_job_id::text || '_' || stage_counter::text || '_' || stage_mapping.stage_id::text)\n    );\n    \n    stage_counter := stage_counter + 1;\n  END LOOP;\n  \n  -- Mark the job as having a custom workflow\n  EXECUTE format('UPDATE %I SET has_custom_workflow = TRUE, updated_at = now() WHERE id = $1', "
  },
  {
    "function_schema": "public",
    "function_name": "initialize_job_stages",
    "args": "p_job_id uuid, p_job_table_name text, p_category_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.initialize_job_stages(p_job_id uuid, p_job_table_name text, p_category_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  stage_record RECORD;\n  first_stage BOOLEAN := TRUE;\nBEGIN\n  -- Create stage instances for each stage in the category\n  FOR stage_record IN\n    SELECT \n      cps.production_stage_id,\n      cps.stage_order,\n      cps.estimated_duration_hours\n    FROM public.category_production_stages cps\n    WHERE cps.category_id = p_category_id\n    ORDER BY cps.stage_order ASC\n  LOOP\n    INSERT INTO public.job_stage_instances (\n      job_id,\n      job_table_name,\n      category_id,\n      production_stage_id,\n      stage_order,\n      status,\n      started_at,\n      started_by\n    ) VALUES (\n      p_job_id,\n      p_job_table_name,\n      p_category_id,\n      stage_record.production_stage_id,\n      stage_record.stage_order,\n      CASE WHEN first_stage THEN 'active' ELSE 'pending' END,\n      CASE WHEN first_stage THEN now() ELSE NULL END,\n      CASE WHEN first_stage THEN auth.uid() ELSE NULL END\n    );\n    \n    first_stage := FALSE;\n  END LOOP;\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "initialize_job_stages_auto",
    "args": "p_job_id uuid, p_job_table_name text, p_category_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.initialize_job_stages_auto(p_job_id uuid, p_job_table_name text, p_category_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  stage_record RECORD;\nBEGIN\n  -- Create stage instances for each stage in the category (ALL starting as pending)\n  FOR stage_record IN\n    SELECT \n      cps.production_stage_id,\n      cps.stage_order,\n      cps.estimated_duration_hours,\n      ps.running_speed_per_hour,\n      ps.make_ready_time_minutes,\n      ps.speed_unit\n    FROM public.category_production_stages cps\n    JOIN public.production_stages ps ON cps.production_stage_id = ps.id\n    WHERE cps.category_id = p_category_id\n      AND ps.is_active = true\n    ORDER BY cps.stage_order ASC\n  LOOP\n    INSERT INTO public.job_stage_instances (\n      job_id,\n      job_table_name,\n      category_id,\n      production_stage_id,\n      stage_order,\n      status,\n      part_assignment,\n      quantity,\n      estimated_duration_minutes,\n      setup_time_minutes\n    ) VALUES (\n      p_job_id,\n      p_job_table_name,\n      p_category_id,\n      stage_record.production_stage_id,\n      stage_record.stage_order,\n      'pending', -- ALL stages start as pending - NO auto-activation\n      'both', -- Default part assignment\n      NULL, -- Will be set later when quantities are assigned\n      NULL, -- Will be calculated when quantities are assigned\n      COALESCE(stage_record.make_ready_time_minutes, 10) -- Default setup time\n    );\n  END LOOP;\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "initialize_job_stages_concurrent",
    "args": "p_job_id uuid, p_job_table_name text, p_category_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.initialize_job_stages_concurrent(p_job_id uuid, p_job_table_name text, p_category_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  stage_record RECORD;\n  printing_group_id UUID := gen_random_uuid();\n  dependency_group_id UUID := gen_random_uuid();\n  part_name TEXT;\n  is_first_stage BOOLEAN := true;\nBEGIN\n  -- Create stage instances for each stage in the category\n  FOR stage_record IN\n    SELECT \n      cps.production_stage_id,\n      cps.stage_order,\n      ps.name as stage_name,\n      ps.is_multi_part,\n      ps.part_definitions\n    FROM public.category_production_stages cps\n    JOIN public.production_stages ps ON cps.production_stage_id = ps.id\n    WHERE cps.category_id = p_category_id\n    ORDER BY cps.stage_order ASC\n  LOOP\n    -- Handle multi-part printing stages\n    IF stage_record.is_multi_part AND stage_record.stage_name ILIKE '%printing%' THEN\n      FOR part_name IN SELECT jsonb_array_elements_text(stage_record.part_definitions)\n      LOOP\n        INSERT INTO public.job_stage_instances (\n          job_id,\n          job_table_name,\n          category_id,\n          production_stage_id,\n          stage_order,\n          part_name,\n          status,\n          allows_concurrent_start,\n          concurrent_stage_group_id,\n          stage_dependency_group\n        ) VALUES (\n          p_job_id,\n          p_job_table_name,\n          p_category_id,\n          stage_record.production_stage_id,\n          stage_record.stage_order,\n          part_name,\n          'pending',\n          true,\n          printing_group_id,\n          dependency_group_id\n        );\n      END LOOP;\n    \n    -- Handle part-specific stages like laminating (only for covers)\n    ELSIF stage_record.stage_name ILIKE '%laminating%' THEN\n      INSERT INTO public.job_stage_instances (\n        job_id,\n        job_table_name,\n        category_id,\n        production_stage_id,\n        stage_order,\n        part_name,\n        status,\n        stage_dependency_group\n      ) VALUES (\n        p_job_id,\n        p_job_table_name,\n        p_category_id,\n        stage_record.production_stage_id,\n        stage_record.stage_order,\n        'covers',\n        'pending',\n        dependency_group_id\n      );\n    \n    -- Handle finishing stages that need all parts complete\n    ELSIF stage_record.stage_name ILIKE ANY(ARRAY['%finishing%', '%gathering%', '%binding%', '%cutting%']) THEN\n      INSERT INTO public.job_stage_instances (\n        job_id,\n        job_table_name,\n        category_id,\n        production_stage_id,\n        stage_order,\n        status,\n        requires_all_parts_complete\n      ) VALUES (\n        p_job_id,\n        p_job_table_name,\n        p_category_id,\n        stage_record.production_stage_id,\n        stage_record.stage_order,\n        'blocked', -- Blocked until all parts complete\n        true\n      );\n    \n    -- Handle regular single-part stages\n    ELSE\n      INSERT INTO public.job_stage_instances (\n        job_id,\n        job_table_name,\n        category_id,\n        production_stage_id,\n        stage_order,\n        status\n      ) VALUES (\n        p_job_id,\n        p_job_table_name,\n        p_category_id,\n        stage_record.production_stage_id,\n        stage_record.stage_order,\n        CASE WHEN is_first_stage THEN 'pending' ELSE 'pending' END\n      );\n    END IF;\n    \n    is_first_stage := false;\n  END LOOP;\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "inject_batch_allocation_stage_for_existing_jobs",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.inject_batch_allocation_stage_for_existing_jobs()\n RETURNS TABLE(fixed_job_id uuid, wo_no text, category_name text, stages_added integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  job_record RECORD;\n  batch_allocation_stage_id UUID;\n  stages_count INTEGER;\n  next_stage_order INTEGER;\nBEGIN\n  -- Find the Batch Allocation stage\n  SELECT id INTO batch_allocation_stage_id\n  FROM public.production_stages\n  WHERE name = 'Batch Allocation'\n  LIMIT 1;\n  \n  IF batch_allocation_stage_id IS NULL THEN\n    RAISE EXCEPTION 'Batch Allocation stage not found';\n  END IF;\n  \n  -- Find jobs that need the Batch Allocation stage injected\n  FOR job_record IN\n    SELECT \n      pj.id,\n      pj.wo_no,\n      pj.category_id,\n      c.name as category_name\n    FROM public.production_jobs pj\n    JOIN public.categories c ON pj.category_id = c.id\n    JOIN public.category_production_stages cps ON (\n      cps.category_id = pj.category_id \n      AND cps.production_stage_id = batch_allocation_stage_id\n    )\n    LEFT JOIN public.job_stage_instances jsi ON (\n      jsi.job_id = pj.id \n      AND jsi.job_table_name = 'production_jobs'\n      AND jsi.production_stage_id = batch_allocation_stage_id\n    )\n    WHERE jsi.id IS NULL -- Job doesn't have this stage yet\n      AND pj.category_id IS NOT NULL\n  LOOP\n    -- Get the correct stage order from category definition\n    SELECT cps.stage_order INTO next_stage_order\n    FROM public.category_production_stages cps\n    WHERE cps.category_id = job_record.category_id\n      AND cps.production_stage_id = batch_allocation_stage_id;\n    \n    -- Insert the missing Batch Allocation stage\n    INSERT INTO public.job_stage_instances (\n      job_id,\n      job_table_name,\n      category_id,\n      production_stage_id,\n      stage_order,\n      status\n    ) VALUES (\n      job_record.id,\n      'production_jobs',\n      job_record.category_id,\n      batch_allocation_stage_id,\n      next_stage_order,\n      'pending'\n    );\n    \n    stages_count := 1;\n    \n    -- Return the repair result\n    RETURN QUERY SELECT \n      job_record.id,\n      job_record.wo_no,\n      job_record.category_name,\n      stages_count;\n  END LOOP;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "is_admin",
    "args": "_user_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.is_admin(_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  -- Check if the user has admin role in the user_roles table\n  RETURN EXISTS (\n    SELECT 1\n    FROM public.user_roles\n    WHERE user_id = _user_id\n    AND role = 'admin'\n  );\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "is_admin_secure_fixed",
    "args": "_user_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.is_admin_secure_fixed(_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  -- Check if the user has admin role in the user_roles table\n  RETURN EXISTS (\n    SELECT 1\n    FROM public.user_roles\n    WHERE user_id = _user_id\n    AND role = 'admin'\n  );\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "is_admin_simple",
    "args": "",
    "language": "sql",
    "security_definer": true,
    "volatility": "s",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.is_admin_simple()\n RETURNS boolean\n LANGUAGE sql\n STABLE SECURITY DEFINER\nAS $function$\n  SELECT EXISTS (\n    SELECT 1 FROM public.user_roles \n    WHERE user_id = auth.uid() AND role = 'admin'\n  );\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "is_public_holiday",
    "args": "check_date date",
    "language": "sql",
    "security_definer": true,
    "volatility": "s",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.is_public_holiday(check_date date)\n RETURNS boolean\n LANGUAGE sql\n STABLE SECURITY DEFINER\nAS $function$\n  SELECT EXISTS (\n    SELECT 1 FROM public.public_holidays \n    WHERE date = check_date AND is_active = true\n  );\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "is_user_admin",
    "args": "check_user_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.is_user_admin(check_user_id uuid DEFAULT auth.uid())\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 \n    FROM public.user_roles \n    WHERE user_id = check_user_id \n    AND role = 'admin'\n  );\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "list_working_days",
    "args": "start_date date, end_date date",
    "language": "sql",
    "security_definer": false,
    "volatility": "s",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.list_working_days(start_date date, end_date date)\n RETURNS TABLE(work_date date)\n LANGUAGE sql\n STABLE\nAS $function$\r\n  with base as (\r\n    select d::date as d\r\n    from generate_series(start_date, end_date, interval '1 day') g(d)\r\n  ),\r\n  holidays as (\r\n    select ph.date::date as d  -- <-- correct column name\r\n    from public_holidays ph\r\n    where coalesce(ph.is_active,true) = true\r\n  ),\r\n  working_dow as (\r\n    select day_of_week, is_working_day\r\n    from shift_schedules\r\n    where is_active = true\r\n  )\r\n  select b.d as work_date\r\n  from base b\r\n  join working_dow w on w.day_of_week = extract(dow from b.d)::int\r\n  left join holidays h on h.d = b.d\r\n  where w.is_working_day = true\r\n    and h.d is null\r\n  order by b.d;\r\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "mark_job_ready_for_batching",
    "args": "p_job_id uuid, p_job_table_name text, p_user_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.mark_job_ready_for_batching(p_job_id uuid, p_job_table_name text, p_user_id uuid DEFAULT auth.uid())\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Update the appropriate job table\n  EXECUTE format('\n    UPDATE %I \n    SET batch_ready = true, \n        batch_allocated_at = now(), \n        batch_allocated_by = $1\n    WHERE id = $2\n  ', p_job_table_name) \n  USING p_user_id, p_job_id;\n  \n  RETURN true;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "mirror_jsi_to_stage_time_slots",
    "args": "p_stage_ids uuid[]",
    "language": "sql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.mirror_jsi_to_stage_time_slots(p_stage_ids uuid[])\n RETURNS void\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\r\n  insert into public.stage_time_slots (\r\n    production_stage_id,\r\n    job_id,\r\n    stage_instance_id,\r\n    date,\r\n    slot_start_time,\r\n    slot_end_time,\r\n    duration_minutes\r\n  )\r\n  select\r\n    jsi.production_stage_id,\r\n    jsi.job_id,\r\n    jsi.id,\r\n    (jsi.scheduled_start_at at time zone 'UTC')::date,           -- keep if you store date\r\n    jsi.scheduled_start_at,\r\n    jsi.scheduled_end_at,\r\n    greatest(\r\n      coalesce(jsi.scheduled_minutes, 0),\r\n      extract(epoch from (jsi.scheduled_end_at - jsi.scheduled_start_at))::int / 60\r\n    )\r\n  from public.job_stage_instances jsi\r\n  where jsi.id = any(p_stage_ids)\r\n    and jsi.scheduled_start_at is not null\r\n    and jsi.scheduled_end_at   is not null\r\n    and jsi.production_stage_id is not null\r\n  on conflict on constraint stage_time_slots_production_stage_id_slot_start_time_key\r\n  do update set\r\n    job_id            = excluded.job_id,\r\n    stage_instance_id = excluded.stage_instance_id,\r\n    date              = excluded.date,\r\n    slot_end_time     = excluded.slot_end_time,\r\n    duration_minutes  = excluded.duration_minutes;\r\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "notify_scheduler_on_proof_approval",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.notify_scheduler_on_proof_approval()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\ndeclare\r\n  --  CONFIG: your Edge Function URL + anon key\r\n  fn_url text := 'https://kgizusgqexmlfcqfjopk.functions.supabase.co/scheduler-run';\r\n  anon   text := 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtnaXp1c2dxZXhtbGZjcWZqb3BrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ1NTQwNzAsImV4cCI6MjA2MDEzMDA3MH0.NA2wRme-L8Z15my7n8u-BCQtO4Nw2opfsX0KSLYcs-I';\r\n\r\n  v_request_id bigint;\r\n  v_status     int;\r\n  v_body       text;\r\n  v_headers    jsonb;\r\nbegin\r\n  -- Fire only when proof_approved_at flips from NULL -> NOT NULL or changes\r\n  if tg_op = 'UPDATE'\r\n     and new.proof_approved_at is not null\r\n     and (old.proof_approved_at is null or old.proof_approved_at is distinct from new.proof_approved_at)\r\n  then\r\n    -- 1) enqueue the HTTP call (pg_net returns a request id on some versions)\r\n    begin\r\n      select net.http_post(\r\n               url := fn_url,\r\n               headers := jsonb_build_object(\r\n                 'Content-Type','application/json',\r\n                 'Authorization','Bearer ' || anon\r\n               ),\r\n               body := jsonb_build_object(\r\n                 'commit', true,\r\n                 'proposed', false,\r\n                 'onlyIfUnset', true,         -- schedule only unscheduled instances\r\n                 'nuclear', false,\r\n                 'onlyJobIds', jsonb_build_array(new.id)  -- schedule only this job\r\n               ),\r\n               timeout_milliseconds := 8000\r\n             )::bigint\r\n      into v_request_id;\r\n\r\n    exception when undefined_function then\r\n      -- Fallback: some pg_net builds return a RECORD instead of a bigint (rare on Supabase now).\r\n      -- Try to get immediate status/body from a record signature.\r\n      declare\r\n        r record;\r\n      begin\r\n        select * from net.http_post(\r\n                 url := fn_url,\r\n                 headers := jsonb_build_object(\r\n                   'Content-Type','application/json',\r\n                   'Authorization','Bearer ' || anon\r\n                 ),\r\n                 body := jsonb_build_object(\r\n                   'commit', true,\r\n                   'proposed', false,\r\n                   'onlyIfUnset', true,\r\n                   'nuclear', false,\r\n                   'onlyJobIds', jsonb_build_array(new.id)\r\n                 ),\r\n                 timeout_milliseconds := 8000\r\n               ) as r(status int, headers jsonb, body text)\r\n        into r;\r\n        v_status := r.status;\r\n        v_headers := r.headers;\r\n        v_body := r.body;\r\n      end;\r\n    end;\r\n\r\n    -- 2) If we got a request id, try to collect the response.\r\n    if v_request_id is not null then\r\n      begin\r\n        -- Newer internal collector name on Supabase\r\n        select r.status, r.headers, r.body\r\n        into v_status, v_headers, v_body\r\n        from net._http_collect_response(v_request_id) as r;\r\n\r\n      exception when undefined_function then\r\n        -- If the internal collector function name differs, swallow; we still log the request id.\r\n        null;\r\n      end;\r\n    end if;\r\n\r\n    -- 3) Log what we did (always)\r\n    insert into public.scheduler_webhook_log(\r\n      job_id, order_no, event, request_id, http_status, response_excerpt, error_text\r\n    )\r\n    values (\r\n      new.id,\r\n      new.order_no,\r\n      'proof-approved',\r\n      v_request_id,\r\n      v_status,\r\n      case when v_body is null then null else left(v_body, 4000) end,\r\n      null\r\n    );\r\n  end if;\r\n\r\n  return new;\r\nend\r\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "prevent_concurrent_stage_changes",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.prevent_concurrent_stage_changes()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  current_status TEXT;\nBEGIN\n  -- Re-check current status to prevent race conditions\n  SELECT status INTO current_status\n  FROM public.job_stage_instances\n  WHERE id = NEW.id\n  FOR UPDATE; -- Lock the row\n  \n  -- Validate status transition\n  IF OLD.status = 'completed' AND NEW.status != 'completed' THEN\n    RAISE EXCEPTION 'Cannot change status of completed stage instance %', NEW.id;\n  END IF;\n  \n  IF OLD.status = 'active' AND NEW.status = 'pending' THEN\n    -- Only allow if explicitly reworking\n    IF NEW.is_rework IS NOT TRUE THEN\n      RAISE EXCEPTION 'Cannot revert active stage to pending without rework flag';\n    END IF;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "process_due_date_recalculation_queue",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.process_due_date_recalculation_queue()\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  queue_item RECORD;\n  processed_count INTEGER := 0;\nBEGIN\n  -- Process unprocessed queue items\n  FOR queue_item IN\n    SELECT id, job_id, job_table_name\n    FROM public.due_date_recalculation_queue\n    WHERE processed = false\n      AND created_at > now() - interval '1 hour' -- Only process recent items\n    ORDER BY created_at\n    LIMIT 100 -- Process in batches\n  LOOP\n    -- Mark as processed\n    UPDATE public.due_date_recalculation_queue\n    SET \n      processed = true,\n      processed_at = now()\n    WHERE id = queue_item.id;\n    \n    processed_count := processed_count + 1;\n  END LOOP;\n  \n  -- Clean up old processed items (older than 24 hours)\n  DELETE FROM public.due_date_recalculation_queue\n  WHERE processed = true \n    AND processed_at < now() - interval '24 hours';\n  \n  RETURN processed_count;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "reassign_jobs_to_category",
    "args": "p_from_category_id uuid, p_to_category_id uuid, p_user_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.reassign_jobs_to_category(p_from_category_id uuid, p_to_category_id uuid, p_user_id uuid DEFAULT auth.uid())\n RETURNS TABLE(jobs_reassigned integer, stages_updated integer, success boolean, error_message text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  jobs_count integer := 0;\n  stages_count integer := 0;\n  error_msg text := '';\nBEGIN\n  -- Check if both categories exist\n  IF NOT EXISTS (SELECT 1 FROM public.categories WHERE id = p_from_category_id) THEN\n    RETURN QUERY SELECT 0, 0, false, 'Source category does not exist';\n    RETURN;\n  END IF;\n  \n  IF NOT EXISTS (SELECT 1 FROM public.categories WHERE id = p_to_category_id) THEN\n    RETURN QUERY SELECT 0, 0, false, 'Target category does not exist';\n    RETURN;\n  END IF;\n  \n  BEGIN\n    -- Update production jobs\n    UPDATE public.production_jobs\n    SET category_id = p_to_category_id, updated_at = now()\n    WHERE category_id = p_from_category_id;\n    \n    GET DIAGNOSTICS jobs_count = ROW_COUNT;\n    \n    -- Update job stage instances\n    UPDATE public.job_stage_instances\n    SET category_id = p_to_category_id, updated_at = now()\n    WHERE category_id = p_from_category_id;\n    \n    GET DIAGNOSTICS stages_count = ROW_COUNT;\n    \n    RETURN QUERY SELECT jobs_count, stages_count, true, 'Jobs reassigned successfully'::text;\n    \n  EXCEPTION WHEN OTHERS THEN\n    error_msg := SQLERRM;\n    RETURN QUERY SELECT 0, 0, false, error_msg;\n  END;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "remove_job_expedite_status",
    "args": "p_job_id uuid, p_removed_by uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.remove_job_expedite_status(p_job_id uuid, p_removed_by uuid DEFAULT auth.uid())\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Remove expedite status from production job  \n  UPDATE public.production_jobs\n  SET \n    is_expedited = false,\n    expedited_at = null,\n    expedited_by = null,\n    expedite_reason = null,\n    updated_at = now()\n  WHERE id = p_job_id;\n\n  -- Reset job order in stages to default (will be recalculated by ordering service)\n  UPDATE public.job_stage_instances\n  SET \n    job_order_in_stage = 1,\n    updated_at = now()\n  WHERE job_id = p_job_id \n    AND job_table_name = 'production_jobs'\n    AND job_order_in_stage = 0;\n\n  RETURN true;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "reorder_category_stages_safe",
    "args": "p_category_id uuid, p_stage_reorders jsonb",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.reorder_category_stages_safe(p_category_id uuid, p_stage_reorders jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  stage_update RECORD;\n  temp_offset INTEGER := 10000;\n  result_count INTEGER := 0;\n  error_message TEXT := '';\nBEGIN\n  -- Validate input\n  IF p_category_id IS NULL OR p_stage_reorders IS NULL THEN\n    RETURN jsonb_build_object(\n      'success', false,\n      'error', 'Invalid parameters: category_id and stage_reorders required'\n    );\n  END IF;\n\n  BEGIN\n    -- Step 1: Move all stages to temporary high numbers to avoid conflicts\n    UPDATE public.category_production_stages \n    SET \n      stage_order = stage_order + temp_offset,\n      updated_at = now()\n    WHERE category_id = p_category_id;\n\n    -- Step 2: Update to final positions from the reorder data\n    FOR stage_update IN \n      SELECT \n        (value->>'id')::uuid as stage_id,\n        (value->>'stage_order')::integer as new_order\n      FROM jsonb_array_elements(p_stage_reorders)\n    LOOP\n      UPDATE public.category_production_stages\n      SET \n        stage_order = stage_update.new_order,\n        updated_at = now()\n      WHERE id = stage_update.stage_id \n        AND category_id = p_category_id;\n        \n      GET DIAGNOSTICS result_count = ROW_COUNT;\n      \n      IF result_count = 0 THEN\n        RAISE EXCEPTION 'Stage with id % not found in category %', stage_update.stage_id, p_category_id;\n      END IF;\n    END LOOP;\n\n    -- Step 3: Verify sequential ordering and fix any gaps\n    WITH ordered_stages AS (\n      SELECT \n        id, \n        ROW_NUMBER() OVER (ORDER BY stage_order) as correct_order\n      FROM public.category_production_stages \n      WHERE category_id = p_category_id\n    )\n    UPDATE public.category_production_stages \n    SET \n      stage_order = ordered_stages.correct_order,\n      updated_at = now()\n    FROM ordered_stages \n    WHERE category_production_stages.id = ordered_stages.id;\n\n    RETURN jsonb_build_object(\n      'success', true,\n      'message', 'Category stages reordered successfully'\n    );\n\n  EXCEPTION WHEN OTHERS THEN\n    error_message := SQLERRM;\n    \n    -- Rollback: restore original sequential order\n    WITH ordered_stages AS (\n      SELECT \n        id, \n        ROW_NUMBER() OVER (ORDER BY created_at) as restore_order\n      FROM public.category_production_stages \n      WHERE category_id = p_category_id\n    )\n    UPDATE public.category_production_stages \n    SET \n      stage_order = ordered_stages.restore_order,\n      updated_at = now()\n    FROM ordered_stages \n    WHERE category_production_stages.id = ordered_stages.id;\n    \n    RETURN jsonb_build_object(\n      'success', false,\n      'error', format('Reordering failed: %s. Restored original order.', error_message)\n    );\n  END;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "reorder_jobs_in_master_queue",
    "args": "p_job_reorders jsonb, p_master_queue_stage_id uuid, p_reordered_by uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.reorder_jobs_in_master_queue(p_job_reorders jsonb, p_master_queue_stage_id uuid, p_reordered_by uuid DEFAULT auth.uid())\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  job_reorder RECORD;\nBEGIN\n  -- Update job order for all jobs in the reorder list\n  FOR job_reorder IN \n    SELECT \n      (value->>'job_id')::uuid as job_id,\n      (value->>'new_order')::integer as new_order\n    FROM jsonb_array_elements(p_job_reorders)\n  LOOP\n    -- Update job_order_in_stage for all stage instances of this job\n    -- This ensures multi-part jobs maintain consistent ordering across subsidiary stages\n    UPDATE public.job_stage_instances\n    SET \n      job_order_in_stage = job_reorder.new_order,\n      updated_at = now()\n    WHERE job_id = job_reorder.job_id\n      AND job_table_name = 'production_jobs'\n      AND (\n        production_stage_id = p_master_queue_stage_id OR \n        production_stage_id IN (\n          SELECT id FROM public.production_stages \n          WHERE master_queue_id = p_master_queue_stage_id\n        )\n      );\n  END LOOP;\n\n  -- Log job reordering activity\n  INSERT INTO public.job_stage_instances (\n    job_id,\n    job_table_name,\n    production_stage_id,\n    stage_order,\n    status,\n    notes\n  )\n  SELECT \n    (p_job_reorders->0->>'job_id')::uuid,\n    'production_jobs',\n    p_master_queue_stage_id,\n    999,\n    'completed',\n    'Master queue reordered by manager'\n  WHERE jsonb_array_length(p_job_reorders) > 0;\n\n  RETURN true;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "repair_batch_job_references",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.repair_batch_job_references()\n RETURNS TABLE(repaired_table text, repaired_job_id uuid, job_number text, created_reference boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  job_record RECORD;\n  production_job_id_found uuid;\n  job_table text;\n  job_tables text[] := ARRAY['business_card_jobs', 'flyer_jobs', 'postcard_jobs', 'poster_jobs', 'sticker_jobs', 'cover_jobs', 'sleeve_jobs', 'box_jobs'];\nBEGIN\n  FOREACH job_table IN ARRAY job_tables LOOP\n    FOR job_record IN EXECUTE format('\n      SELECT \n        j.id,\n        j.batch_id,\n        j.job_number\n      FROM %I j\n      WHERE j.batch_id IS NOT NULL\n        AND j.job_number IS NOT NULL\n        AND j.job_number != ''''\n        AND NOT EXISTS (\n          SELECT 1 FROM public.batch_job_references bjr \n          WHERE bjr.batch_job_id = j.id \n          AND bjr.batch_job_table = %L\n        )\n    ', job_table, job_table)\n    LOOP\n      -- Find matching production job\n      SELECT pj.id INTO production_job_id_found\n      FROM public.production_jobs pj\n      WHERE pj.wo_no = job_record.job_number\n      LIMIT 1;\n      \n      IF production_job_id_found IS NOT NULL THEN\n        -- Create the missing reference\n        INSERT INTO public.batch_job_references (\n          batch_id,\n          batch_job_id,\n          batch_job_table,\n          production_job_id,\n          status,\n          created_at\n        ) VALUES (\n          job_record.batch_id,\n          job_record.id,\n          job_table,\n          production_job_id_found,\n          'pending',\n          now()\n        ) ON CONFLICT (production_job_id, batch_id) DO NOTHING;\n        \n        RETURN QUERY SELECT job_table::text, job_record.id::uuid, job_record.job_number::text, true::boolean;\n      ELSE\n        RETURN QUERY SELECT job_table::text, job_record.id::uuid, job_record.job_number::text, false::boolean;\n      END IF;\n    END LOOP;\n  END LOOP;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "repair_jobs_missing_stages",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.repair_jobs_missing_stages()\n RETURNS TABLE(repaired_job_id uuid, job_wo_no text, category_name text, stages_created integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  job_record RECORD;\n  stages_count INTEGER;\nBEGIN\n  -- Find jobs that have categories but no stage instances\n  FOR job_record IN\n    SELECT \n      pj.id,\n      pj.wo_no,\n      pj.category_id,\n      c.name as category_name\n    FROM public.production_jobs pj\n    JOIN public.categories c ON pj.category_id = c.id\n    LEFT JOIN public.job_stage_instances jsi ON (\n      jsi.job_id = pj.id \n      AND jsi.job_table_name = 'production_jobs'\n    )\n    WHERE pj.category_id IS NOT NULL\n      AND jsi.id IS NULL\n  LOOP\n    -- Initialize stages for this job using the standard function\n    PERFORM public.initialize_job_stages_auto(\n      job_record.id,\n      'production_jobs',\n      job_record.category_id\n    );\n    \n    -- Count how many stages were created\n    SELECT COUNT(*) INTO stages_count\n    FROM public.job_stage_instances\n    WHERE job_id = job_record.id AND job_table_name = 'production_jobs';\n    \n    -- Return the repair result\n    RETURN QUERY SELECT \n      job_record.id,\n      job_record.wo_no,\n      job_record.category_name,\n      stages_count;\n  END LOOP;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "repair_missing_batch_references_fixed",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.repair_missing_batch_references_fixed()\n RETURNS TABLE(batch_id uuid, batch_name text, references_created integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  batch_record RECORD;\n  created_count integer := 0;\n  total_created integer := 0;\nBEGIN\n  -- Loop through each batch that has missing references\n  FOR batch_record IN\n    SELECT DISTINCT b.id, b.name\n    FROM public.batches b\n    WHERE b.status != 'completed'\n  LOOP\n    total_created := 0;\n    \n    -- Handle flyer_jobs\n    INSERT INTO public.batch_job_references (\n      batch_id,\n      batch_job_id,\n      batch_job_table,\n      production_job_id,\n      status\n    )\n    SELECT \n      batch_record.id as batch_id,\n      fj.id as batch_job_id,\n      'flyer_jobs' as batch_job_table,\n      pj.id as production_job_id,\n      'pending' as status\n    FROM flyer_jobs fj\n    JOIN production_jobs pj ON fj.job_number = pj.wo_no\n    LEFT JOIN public.batch_job_references bjr ON (\n      bjr.batch_job_id = fj.id \n      AND bjr.batch_job_table = 'flyer_jobs'\n    )\n    WHERE fj.batch_id = batch_record.id\n      AND bjr.id IS NULL;\n    \n    GET DIAGNOSTICS created_count = ROW_COUNT;\n    total_created := total_created + created_count;\n    \n    -- Handle business_card_jobs\n    INSERT INTO public.batch_job_references (\n      batch_id,\n      batch_job_id,\n      batch_job_table,\n      production_job_id,\n      status\n    )\n    SELECT \n      batch_record.id as batch_id,\n      bcj.id as batch_job_id,\n      'business_card_jobs' as batch_job_table,\n      pj.id as production_job_id,\n      'pending' as status\n    FROM business_card_jobs bcj\n    JOIN production_jobs pj ON bcj.job_number = pj.wo_no\n    LEFT JOIN public.batch_job_references bjr ON (\n      bjr.batch_job_id = bcj.id \n      AND bjr.batch_job_table = 'business_card_jobs'\n    )\n    WHERE bcj.batch_id = batch_record.id\n      AND bjr.id IS NULL;\n    \n    GET DIAGNOSTICS created_count = ROW_COUNT;\n    total_created := total_created + created_count;\n    \n    -- Handle postcard_jobs\n    INSERT INTO public.batch_job_references (\n      batch_id,\n      batch_job_id,\n      batch_job_table,\n      production_job_id,\n      status\n    )\n    SELECT \n      batch_record.id as batch_id,\n      pj.id as batch_job_id,\n      'postcard_jobs' as batch_job_table,\n      prod_job.id as production_job_id,\n      'pending' as status\n    FROM postcard_jobs pj\n    JOIN production_jobs prod_job ON pj.job_number = prod_job.wo_no\n    LEFT JOIN public.batch_job_references bjr ON (\n      bjr.batch_job_id = pj.id \n      AND bjr.batch_job_table = 'postcard_jobs'\n    )\n    WHERE pj.batch_id = batch_record.id\n      AND bjr.id IS NULL;\n    \n    GET DIAGNOSTICS created_count = ROW_COUNT;\n    total_created := total_created + created_count;\n    \n    -- Handle other job types (poster_jobs, sticker_jobs, cover_jobs, sleeve_jobs, box_jobs)\n    INSERT INTO public.batch_job_references (\n      batch_id,\n      batch_job_id,\n      batch_job_table,\n      production_job_id,\n      status\n    )\n    SELECT \n      batch_record.id as batch_id,\n      poster_job.id as batch_job_id,\n      'poster_jobs' as batch_job_table,\n      prod_job.id as production_job_id,\n      'pending' as status\n    FROM poster_jobs poster_job\n    JOIN production_jobs prod_job ON poster_job.job_number = prod_job.wo_no\n    LEFT JOIN public.batch_job_references bjr ON (\n      bjr.batch_job_id = poster_job.id \n      AND bjr.batch_job_table = 'poster_jobs'\n    )\n    WHERE poster_job.batch_id = batch_record.id\n      AND bjr.id IS NULL;\n    \n    GET DIAGNOSTICS created_count = ROW_COUNT;\n    total_created := total_created + created_count;\n    \n    -- Continue with remaining job types...\n    -- (Adding each separately to avoid column name conflicts)\n    \n    -- Return results for batches that had references created\n    IF total_created > 0 THEN\n      RETURN QUERY SELECT \n        batch_record.id,\n        batch_record.name,\n        total_created;\n    END IF;\n  END LOOP;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "reset_custom_workflow_stages_to_pending",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.reset_custom_workflow_stages_to_pending()\n RETURNS TABLE(reset_job_id uuid, wo_no text, stages_reset integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  job_record RECORD;\n  reset_count INTEGER;\nBEGIN\n  -- Find jobs with custom workflows that have auto-started stages\n  FOR job_record IN\n    SELECT DISTINCT \n      pj.id,\n      pj.wo_no\n    FROM public.production_jobs pj\n    INNER JOIN public.job_stage_instances jsi ON pj.id = jsi.job_id\n    WHERE pj.has_custom_workflow = true\n      AND jsi.job_table_name = 'production_jobs'\n      AND jsi.status = 'active'\n      AND jsi.started_at IS NOT NULL\n  LOOP\n    -- Reset all active stages to pending for this custom workflow job\n    UPDATE public.job_stage_instances\n    SET \n      status = 'pending',\n      started_at = NULL,\n      started_by = NULL,\n      updated_at = now()\n    WHERE job_stage_instances.job_id = job_record.id\n      AND job_stage_instances.job_table_name = 'production_jobs'\n      AND job_stage_instances.status = 'active';\n    \n    GET DIAGNOSTICS reset_count = ROW_COUNT;\n    \n    -- Return the job info and count of stages reset\n    RETURN QUERY SELECT \n      job_record.id,\n      job_record.wo_no,\n      reset_count;\n  END LOOP;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "revoke_user_role",
    "args": "target_user_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.revoke_user_role(target_user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  -- Check if user exists\n  IF NOT EXISTS (SELECT 1 FROM auth.users WHERE id = target_user_id) THEN\n    RAISE EXCEPTION 'User with ID % does not exist', target_user_id;\n  END IF;\n  \n  -- Remove role for user\n  DELETE FROM public.user_roles WHERE user_id = target_user_id;\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "rework_job_stage",
    "args": "p_job_id uuid, p_job_table_name text, p_current_stage_id uuid, p_target_stage_id uuid, p_rework_reason text, p_reworked_by uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.rework_job_stage(p_job_id uuid, p_job_table_name text, p_current_stage_id uuid, p_target_stage_id uuid, p_rework_reason text DEFAULT NULL::text, p_reworked_by uuid DEFAULT auth.uid())\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  current_stage_order INTEGER;\n  target_stage_order INTEGER;\nBEGIN\n  -- Get the order of both stages\n  SELECT stage_order INTO current_stage_order\n  FROM public.job_stage_instances\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND production_stage_id = p_current_stage_id;\n\n  SELECT stage_order INTO target_stage_order\n  FROM public.job_stage_instances\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND production_stage_id = p_target_stage_id;\n\n  -- Validate that target stage comes before current stage\n  IF target_stage_order >= current_stage_order THEN\n    RETURN FALSE;\n  END IF;\n\n  -- Mark current stage as reworked\n  UPDATE public.job_stage_instances\n  SET \n    status = 'reworked',\n    completed_at = null,\n    completed_by = null,\n    rework_count = rework_count + 1,\n    rework_reason = p_rework_reason,\n    is_rework = true,\n    updated_at = now()\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND production_stage_id = p_current_stage_id;\n\n  -- Reset any stages between target and current to pending\n  UPDATE public.job_stage_instances\n  SET \n    status = 'pending',\n    started_at = null,\n    completed_at = null,\n    started_by = null,\n    completed_by = null,\n    updated_at = now()\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND stage_order > target_stage_order \n    AND stage_order < current_stage_order;\n\n  -- Reactivate the target stage\n  UPDATE public.job_stage_instances\n  SET \n    status = 'active',\n    started_at = now(),\n    started_by = p_reworked_by,\n    completed_at = null,\n    completed_by = null,\n    is_rework = true,\n    updated_at = now()\n  WHERE job_id = p_job_id \n    AND job_table_name = p_job_table_name\n    AND production_stage_id = p_target_stage_id;\n\n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "safe_delete_category",
    "args": "p_category_id uuid, p_user_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.safe_delete_category(p_category_id uuid, p_user_id uuid DEFAULT auth.uid())\n RETURNS TABLE(success boolean, message text, deleted_stages integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  usage_stats RECORD;\n  stages_deleted integer := 0;\nBEGIN\n  -- Check usage stats first\n  SELECT * INTO usage_stats\n  FROM public.get_category_usage_stats(p_category_id);\n  \n  IF NOT usage_stats.can_delete THEN\n    RETURN QUERY SELECT false, usage_stats.blocking_reason, 0;\n    RETURN;\n  END IF;\n  \n  BEGIN\n    -- Delete category production stages first\n    DELETE FROM public.category_production_stages\n    WHERE category_id = p_category_id;\n    \n    GET DIAGNOSTICS stages_deleted = ROW_COUNT;\n    \n    -- Delete the category itself\n    DELETE FROM public.categories\n    WHERE id = p_category_id;\n    \n    IF NOT FOUND THEN\n      RETURN QUERY SELECT false, 'Category not found'::text, stages_deleted;\n      RETURN;\n    END IF;\n    \n    RETURN QUERY SELECT true, 'Category deleted successfully'::text, stages_deleted;\n    \n  EXCEPTION WHEN OTHERS THEN\n    RETURN QUERY SELECT false, SQLERRM, 0;\n  END;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "schedule_job_with_detailed_logging",
    "args": "p_job_id uuid, p_job_table_name text, p_stage_id uuid, p_estimated_minutes integer, p_earliest_start timestamp with time zone",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.schedule_job_with_detailed_logging(p_job_id uuid, p_job_table_name text, p_stage_id uuid, p_estimated_minutes integer, p_earliest_start timestamp with time zone DEFAULT NULL::timestamp with time zone)\n RETURNS TABLE(scheduled_start timestamp with time zone, scheduled_end timestamp with time zone, decision_log_id uuid, reasoning text, capacity_info jsonb)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  stage_capacity_minutes INTEGER;\n  used_capacity_minutes INTEGER;\n  available_minutes INTEGER;\n  schedule_date DATE;\n  slot_start TIMESTAMP WITH TIME ZONE;\n  slot_end TIMESTAMP WITH TIME ZONE;\n  decision_factors JSONB;\n  stage_info JSONB;\n  log_id UUID;\n  reasoning_text TEXT;\n  working_start_hour INTEGER := 8;\n  working_end_hour NUMERIC := 17.5;\nBEGIN\n  -- Default earliest start to now if not provided\n  p_earliest_start := COALESCE(p_earliest_start, now());\n  \n  -- Start with the earliest possible date\n  schedule_date := p_earliest_start::date;\n  \n  -- Skip weekends\n  WHILE EXTRACT(DOW FROM schedule_date) IN (0, 6) LOOP\n    schedule_date := schedule_date + interval '1 day';\n  END LOOP;\n  \n  -- Get stage capacity profile\n  SELECT \n    COALESCE(scp.daily_capacity_hours * 60, 480)\n  INTO stage_capacity_minutes\n  FROM public.stage_capacity_profiles scp\n  WHERE scp.production_stage_id = p_stage_id;\n  \n  -- Default to 8 hours if no capacity profile\n  stage_capacity_minutes := COALESCE(stage_capacity_minutes, 480);\n  \n  -- Find the first available slot within the next 30 days\n  FOR day_offset IN 0..30 LOOP\n    schedule_date := (p_earliest_start::date) + (day_offset || ' days')::interval;\n    \n    -- Skip weekends\n    IF EXTRACT(DOW FROM schedule_date) IN (0, 6) THEN\n      CONTINUE;\n    END IF;\n    \n    -- Calculate used capacity for this date\n    SELECT COALESCE(SUM(\n      COALESCE(jsi.auto_scheduled_duration_minutes, jsi.scheduled_minutes, jsi.estimated_duration_minutes, 60)\n    ), 0) INTO used_capacity_minutes\n    FROM public.job_stage_instances jsi\n    WHERE jsi.production_stage_id = p_stage_id\n      AND jsi.status IN ('pending', 'active', 'completed')\n      AND (\n        jsi.auto_scheduled_start_at::date = schedule_date OR\n        jsi.scheduled_start_at::date = schedule_date\n      );\n    \n    available_minutes := stage_capacity_minutes - used_capacity_minutes;\n    \n    -- Check if there's enough capacity\n    IF available_minutes >= p_estimated_minutes THEN\n      -- Calculate start time: beginning of work day + used time\n      slot_start := schedule_date + (working_start_hour || ' hours')::interval + (used_capacity_minutes || ' minutes')::interval;\n      slot_end := slot_start + (p_estimated_minutes || ' minutes')::interval;\n      \n      -- Check if slot fits within working hours\n      IF EXTRACT(EPOCH FROM slot_end::time) / 3600 <= working_end_hour THEN\n        -- Found a valid slot!\n        \n        -- Prepare decision factors\n        decision_factors := jsonb_build_object(\n          'days_from_earliest', day_offset,\n          'stage_capacity_minutes', stage_capacity_minutes,\n          'used_capacity_minutes', used_capacity_minutes,\n          'available_capacity_minutes', available_minutes,\n          'job_duration_minutes', p_estimated_minutes,\n          'working_start_hour', working_start_hour,\n          'working_end_hour', working_end_hour,\n          'schedule_date', schedule_date,\n          'capacity_utilization_percent', ROUND((used_capacity_minutes + p_estimated_minutes)::numeric / stage_capacity_minutes * 100, 2)\n        );\n        \n        -- Prepare stage info\n        stage_info := jsonb_build_object(\n          'stage_id', p_stage_id,\n          'total_capacity_minutes', stage_capacity_minutes,\n          'capacity_before_job', used_capacity_minutes,\n          'capacity_after_job', used_capacity_minutes + p_estimated_minutes,\n          'utilization_before_percent', ROUND(used_capacity_minutes::numeric / stage_capacity_minutes * 100, 2),\n          'utilization_after_percent', ROUND("
  },
  {
    "function_schema": "public",
    "function_name": "set_user_role",
    "args": "target_user_id uuid, new_role text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.set_user_role(target_user_id uuid, new_role text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  -- Validate role input\n  IF new_role NOT IN ('admin', 'user') THEN\n    RAISE EXCEPTION 'Invalid role: %. Must be admin or user', new_role;\n  END IF;\n  \n  -- Insert or update role\n  INSERT INTO public.user_roles (user_id, role)\n  VALUES (target_user_id, new_role)\n  ON CONFLICT (user_id) \n  DO UPDATE SET role = new_role, updated_at = now();\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "set_user_role_admin",
    "args": "_target_user_id uuid, _new_role text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.set_user_role_admin(_target_user_id uuid, _new_role text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  -- Validate role input\n  IF _new_role NOT IN ('admin', 'user') THEN\n    RAISE EXCEPTION 'Invalid role: %. Must be admin or user', _new_role;\n  END IF;\n  \n  -- Check if user exists\n  IF NOT EXISTS (SELECT 1 FROM auth.users WHERE id = _target_user_id) THEN\n    RAISE EXCEPTION 'User with ID % does not exist', _target_user_id;\n  END IF;\n  \n  -- Insert or update role\n  INSERT INTO public.user_roles (user_id, role)\n  VALUES (_target_user_id, _new_role)\n  ON CONFLICT (user_id) \n  DO UPDATE SET role = _new_role, updated_at = now();\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "split_batch_at_packaging",
    "args": "p_master_job_id uuid, p_split_by uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.split_batch_at_packaging(p_master_job_id uuid, p_split_by uuid DEFAULT auth.uid())\n RETURNS TABLE(split_jobs_count integer, batch_id uuid)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  master_job RECORD;\n  constituent_job RECORD;\n  packaging_stage_id uuid;\n  jobs_split integer := 0;\n  batch_id_result uuid;\nBEGIN\n  -- Get master job details\n  SELECT pj.id, pj.wo_no, pj.batch_category\n  INTO master_job\n  FROM public.production_jobs pj\n  WHERE pj.id = p_master_job_id AND pj.is_batch_master = true;\n  \n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Master job % not found or not a batch master', p_master_job_id;\n  END IF;\n  \n  -- Find the batch ID\n  SELECT b.id INTO batch_id_result\n  FROM public.batches b\n  WHERE b.name = REPLACE(master_job.wo_no, 'BATCH-', '');\n  \n  -- Find packaging stage\n  SELECT id INTO packaging_stage_id\n  FROM public.production_stages\n  WHERE name ILIKE '%packaging%' AND is_active = true\n  LIMIT 1;\n  \n  IF packaging_stage_id IS NULL THEN\n    RAISE EXCEPTION 'Packaging stage not found';\n  END IF;\n  \n  -- Split out constituent jobs and initialize them at packaging stage\n  FOR constituent_job IN\n    SELECT pj.id, pj.category_id\n    FROM public.batch_job_references bjr\n    JOIN public.production_jobs pj ON bjr.production_job_id = pj.id\n    WHERE bjr.batch_id = batch_id_result\n  LOOP\n    -- Update constituent job status back to active workflow\n    UPDATE public.production_jobs\n    SET \n      status = 'Packaging',\n      updated_at = now()\n    WHERE id = constituent_job.id;\n    \n    -- Initialize packaging stage for constituent job\n    INSERT INTO public.job_stage_instances (\n      job_id,\n      job_table_name,\n      category_id,\n      production_stage_id,\n      stage_order,\n      status,\n      started_at,\n      started_by\n    ) VALUES (\n      constituent_job.id,\n      'production_jobs',\n      constituent_job.category_id,\n      packaging_stage_id,\n      100, -- High order for packaging\n      'active',\n      now(),\n      p_split_by\n    );\n    \n    jobs_split := jobs_split + 1;\n  END LOOP;\n  \n  -- Complete and archive the master job\n  UPDATE public.production_jobs\n  SET \n    status = 'Completed',\n    updated_at = now()\n  WHERE id = p_master_job_id;\n  \n  -- Mark all master job stages as completed\n  UPDATE public.job_stage_instances\n  SET \n    status = 'completed',\n    completed_at = now(),\n    completed_by = p_split_by,\n    updated_at = now()\n  WHERE job_id = p_master_job_id;\n  \n  -- Update batch status to completed\n  UPDATE public.batches\n  SET \n    status = 'completed',\n    updated_at = now()\n  WHERE id = batch_id_result;\n  \n  RETURN QUERY SELECT jobs_split, batch_id_result;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "start_concurrent_printing_stages",
    "args": "p_job_id uuid, p_job_table_name text, p_stage_ids uuid[]",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.start_concurrent_printing_stages(p_job_id uuid, p_job_table_name text, p_stage_ids uuid[])\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  stage_id UUID;\n  group_id UUID := gen_random_uuid();\nBEGIN\n  -- Create a concurrent group for this job's printing stages\n  FOREACH stage_id IN ARRAY p_stage_ids\n  LOOP\n    UPDATE public.job_stage_instances\n    SET \n      status = 'active',\n      started_at = now(),\n      started_by = auth.uid(),\n      concurrent_stage_group_id = group_id,\n      allows_concurrent_start = true,\n      updated_at = now()\n    WHERE job_id = p_job_id \n      AND job_table_name = p_job_table_name\n      AND production_stage_id = stage_id\n      AND status = 'pending';\n  END LOOP;\n\n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "sync_completed_jobs_with_batch_flow",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.sync_completed_jobs_with_batch_flow()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  batch_table_names text[] := ARRAY['business_card_jobs', 'flyer_jobs', 'postcard_jobs', 'poster_jobs', 'sticker_jobs', 'cover_jobs', 'sleeve_jobs', 'box_jobs'];\n  table_name text;\n  update_count integer := 0;\n  total_updates integer := 0;\nBEGIN\n  -- Loop through each batch job table\n  FOREACH table_name IN ARRAY batch_table_names LOOP\n    -- Update batch jobs to 'completed' status when their corresponding production job is completed\n    EXECUTE format('\n      UPDATE %I SET \n        status = ''completed'',\n        updated_at = now()\n      FROM public.batch_job_references bjr\n      JOIN public.production_jobs pj ON bjr.production_job_id = pj.id\n      WHERE %I.id = bjr.batch_job_id\n        AND bjr.batch_job_table = %L\n        AND pj.status = ''Completed''\n        AND %I.status != ''completed''\n    ', table_name, table_name, table_name, table_name);\n    \n    GET DIAGNOSTICS update_count = ROW_COUNT;\n    total_updates := total_updates + update_count;\n    \n    IF update_count > 0 THEN\n      RAISE NOTICE 'Updated % completed jobs in %', update_count, table_name;\n    END IF;\n  END LOOP;\n  \n  RAISE NOTICE 'Total batch jobs synchronized: %', total_updates;\n  RETURN true;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "sync_production_jobs_from_batch_completion",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.sync_production_jobs_from_batch_completion()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  sync_count integer := 0;\nBEGIN\n  -- Update production jobs based on completed batch references\n  UPDATE public.production_jobs pj\n  SET \n    status = 'Batch Complete',\n    batch_ready = false,\n    updated_at = now()\n  FROM public.batch_job_references bjr\n  WHERE bjr.production_job_id = pj.id\n    AND bjr.status = 'completed'\n    AND pj.status = 'In Batch Processing';\n    \n  GET DIAGNOSTICS sync_count = ROW_COUNT;\n  \n  RAISE NOTICE 'Synced % production jobs from batch completion', sync_count;\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "sync_profiles_with_auth",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.sync_profiles_with_auth()\n RETURNS TABLE(synced_count integer, fixed_count integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  synced_users integer := 0;\n  fixed_users integer := 0;\nBEGIN\n  -- Check if the current user is an admin\n  IF NOT EXISTS (SELECT 1 FROM public.user_roles WHERE user_id = auth.uid() AND role = 'admin') THEN\n    RAISE EXCEPTION 'Admin access required';\n  END IF;\n  \n  -- Insert missing profiles\n  INSERT INTO public.profiles (id, full_name, created_at, updated_at)\n  SELECT \n    au.id,\n    COALESCE(au.raw_user_meta_data->>'full_name', au.email) as full_name,\n    au.created_at,\n    au.updated_at\n  FROM auth.users au\n  LEFT JOIN public.profiles p ON au.id = p.id\n  WHERE p.id IS NULL;\n  \n  GET DIAGNOSTICS synced_users = ROW_COUNT;\n  \n  -- Update profiles with missing full_name\n  UPDATE public.profiles \n  SET full_name = COALESCE(\n    (SELECT au.raw_user_meta_data->>'full_name' FROM auth.users au WHERE au.id = profiles.id),\n    (SELECT au.email FROM auth.users au WHERE au.id = profiles.id)\n  ),\n  updated_at = now()\n  WHERE full_name IS NULL OR full_name = '';\n  \n  GET DIAGNOSTICS fixed_users = ROW_COUNT;\n  \n  RETURN QUERY SELECT synced_users, fixed_users;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "trigger_due_date_recalculation",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.trigger_due_date_recalculation()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- This function will be called by our application logic\n  -- We store a flag to indicate recalculation is needed\n  INSERT INTO public.due_date_recalculation_queue (\n    job_id, \n    job_table_name, \n    trigger_reason, \n    created_at\n  ) \n  VALUES (\n    COALESCE(NEW.job_id, OLD.job_id),\n    COALESCE(NEW.job_table_name, OLD.job_table_name, 'production_jobs'),\n    TG_OP || '_' || TG_TABLE_NAME,\n    now()\n  )\n  ON CONFLICT (job_id, job_table_name) \n  DO UPDATE SET \n    trigger_reason = EXCLUDED.trigger_reason,\n    created_at = EXCLUDED.created_at;\n  \n  RETURN COALESCE(NEW, OLD);\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "trigger_schedule_on_proof_approval",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.trigger_schedule_on_proof_approval()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\ndeclare\n  is_proof boolean;\n  req_id uuid;\nbegin\n  -- Only when proof approved transitions from NULL to NOT NULL\n  if new.proof_approved_manually_at is not null and (old.proof_approved_manually_at is null) then\n    -- Check this stage is a Proof stage by name\n    select ps.name ilike '%proof%' into is_proof\n    from public.production_stages ps\n    where ps.id = new.production_stage_id;\n\n    if coalesce(is_proof, false) then\n      -- Fire-and-forget call to edge function (public function, handles auth internally)\n      select net.http_post(\n        url := 'https://kgizusgqexmlfcqfjopk.supabase.co/functions/v1/schedule-on-approval',\n        headers := '{\"Content-Type\": \"application/json\"}'::jsonb,\n        body := jsonb_build_object('job_id', new.job_id, 'job_table_name', new.job_table_name)\n      ) into req_id;\n    end if;\n  end if;\n  return new;\nend;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "trigger_simple_scheduler",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.trigger_simple_scheduler()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Only trigger when status changes to something that indicates approval\n  -- Common approval statuses: 'approved', 'ready', 'in production', etc.\n  IF NEW.status IS DISTINCT FROM OLD.status AND \n     (NEW.status ILIKE '%approved%' OR \n      NEW.status ILIKE '%ready%' OR \n      NEW.status ILIKE '%production%' OR\n      NEW.status = 'Pre-Press') THEN\n    \n    -- Call the simple scheduler edge function\n    PERFORM net.http_post(\n      url := 'https://kgizusgqexmlfcqfjopk.supabase.co/functions/v1/simple-scheduler',\n      headers := '{\"Content-Type\": \"application/json\", \"Authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtnaXp1c2dxZXhtbGZjcWZqb3BrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ1NTQwNzAsImV4cCI6MjA2MDEzMDA3MH0.NA2wRme-L8Z15my7n8u-BCQtO4Nw2opfsX0KSLYcs-I\"}'::jsonb,\n      body := jsonb_build_object(\n        'job_id', NEW.id,\n        'job_table_name', 'production_jobs'\n      )\n    );\n    \n    RAISE NOTICE 'Triggered simple scheduler for job % with status %', NEW.id, NEW.status;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "unschedule_auto_stages",
    "args": "from_date date, wipe_all boolean",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.unschedule_auto_stages(from_date date, wipe_all boolean DEFAULT false)\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nbegin\r\n  -- Clear scheduled times in job_stage_instances from 'from_date' onward.\r\n  -- If you don't have schedule_status, just keep the first two predicates.\r\n  update public.job_stage_instances j\r\n     set scheduled_start_at = null,\r\n         scheduled_end_at   = null,\r\n         scheduled_minutes  = null,\r\n         schedule_status    = 'unscheduled'\r\n   where j.scheduled_start_at is not null\r\n     and j.scheduled_start_at::date >= from_date\r\n     and coalesce(j.schedule_status, 'auto') <> 'manual';\r\n\r\n  if wipe_all then\r\n    -- Some environments/policies reject DELETE without WHERE. Use WHERE true.\r\n    delete from public.stage_time_slots where true;\r\n  else\r\n    delete from public.stage_time_slots\r\n     where slot_start_time::date >= from_date;\r\n  end if;\r\n\r\n  return 1;\r\nend\r\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "update_stage_queue_end_time",
    "args": "p_stage_id uuid, p_new_end_time timestamp with time zone, p_date date",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.update_stage_queue_end_time(p_stage_id uuid, p_new_end_time timestamp with time zone, p_date date DEFAULT CURRENT_DATE)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Insert or update the queue end time\n  INSERT INTO public.stage_workload_tracking (\n    production_stage_id,\n    date,\n    queue_ends_at,\n    committed_hours,\n    available_hours,\n    queue_length_hours,\n    pending_jobs_count,\n    active_jobs_count,\n    calculated_at,\n    updated_at\n  ) VALUES (\n    p_stage_id,\n    p_date,\n    p_new_end_time,\n    0, -- Default values\n    8, -- 8 hour working day\n    0,\n    0,\n    0,\n    now(),\n    now()\n  )\n  ON CONFLICT (production_stage_id, date) \n  DO UPDATE SET \n    queue_ends_at = EXCLUDED.queue_ends_at,\n    updated_at = now();\n  \n  RETURN true;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "update_stage_workload_tracking",
    "args": "",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.update_stage_workload_tracking()\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  stage_record RECORD;\n  workload_record RECORD;\n  updated_count INTEGER := 0;\nBEGIN\n  -- Update workload tracking for all active production stages\n  FOR stage_record IN\n    SELECT id, name FROM public.production_stages WHERE is_active = true\n  LOOP\n    -- Calculate current workload for this stage\n    SELECT * INTO workload_record\n    FROM public.calculate_stage_queue_workload(stage_record.id);\n    \n    -- Insert or update today's workload tracking\n    INSERT INTO public.stage_workload_tracking (\n      production_stage_id,\n      date,\n      committed_hours,\n      queue_length_hours,\n      pending_jobs_count,\n      active_jobs_count,\n      calculated_at\n    ) VALUES (\n      stage_record.id,\n      CURRENT_DATE,\n      workload_record.total_active_hours,\n      workload_record.total_pending_hours,\n      workload_record.pending_jobs_count,\n      workload_record.active_jobs_count,\n      now()\n    )\n    ON CONFLICT (production_stage_id, date)\n    DO UPDATE SET\n      committed_hours = EXCLUDED.committed_hours,\n      queue_length_hours = EXCLUDED.queue_length_hours,\n      pending_jobs_count = EXCLUDED.pending_jobs_count,\n      active_jobs_count = EXCLUDED.active_jobs_count,\n      calculated_at = EXCLUDED.calculated_at,\n      updated_at = now();\n    \n    updated_count := updated_count + 1;\n  END LOOP;\n  \n  RETURN updated_count;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "update_user_profile_admin",
    "args": "_user_id uuid, _full_name text",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.update_user_profile_admin(_user_id uuid, _full_name text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nBEGIN\n  -- Check if user exists\n  IF NOT EXISTS (SELECT 1 FROM auth.users WHERE id = _user_id) THEN\n    RAISE EXCEPTION 'User with ID % does not exist', _user_id;\n  END IF;\n  \n  -- Update profile\n  UPDATE public.profiles\n  SET \n    full_name = _full_name,\n    updated_at = now()\n  WHERE id = _user_id;\n  \n  -- Create profile if it doesn't exist\n  IF NOT FOUND THEN\n    INSERT INTO public.profiles (id, full_name, updated_at)\n    VALUES (_user_id, _full_name, now());\n  END IF;\n  \n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "upsert_delivery_specification_mapping",
    "args": "p_excel_text text, p_delivery_method_id uuid, p_address_pattern text, p_is_collection boolean, p_confidence_score integer, p_created_by uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.upsert_delivery_specification_mapping(p_excel_text text, p_delivery_method_id uuid DEFAULT NULL::uuid, p_address_pattern text DEFAULT NULL::text, p_is_collection boolean DEFAULT false, p_confidence_score integer DEFAULT 100, p_created_by uuid DEFAULT auth.uid())\n RETURNS TABLE(mapping_id uuid, action_taken text, previous_confidence integer, new_confidence integer, conflict_detected boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  existing_mapping RECORD;\n  final_mapping_id uuid;\n  action_result text;\n  had_conflict boolean := false;\n  prev_confidence integer := 0;\n  new_confidence integer := p_confidence_score;\n  conflict_count integer;\nBEGIN\n  -- Check for existing mapping\n  SELECT * INTO existing_mapping\n  FROM public.excel_import_mappings\n  WHERE excel_text = p_excel_text \n    AND mapping_type = 'delivery_specification'\n    AND COALESCE(delivery_method_specification_id::text, '') = COALESCE(p_delivery_method_id::text, '')\n    AND is_collection_mapping = p_is_collection;\n  \n  IF existing_mapping.id IS NOT NULL THEN\n    -- Update existing mapping\n    prev_confidence := existing_mapping.confidence_score;\n    new_confidence := GREATEST(existing_mapping.confidence_score + 10, p_confidence_score);\n    \n    UPDATE public.excel_import_mappings\n    SET \n      confidence_score = new_confidence,\n      address_extraction_pattern = COALESCE(p_address_pattern, address_extraction_pattern),\n      updated_at = now(),\n      is_verified = CASE \n        WHEN new_confidence >= 100 THEN true \n        ELSE is_verified \n      END\n    WHERE id = existing_mapping.id;\n    \n    final_mapping_id := existing_mapping.id;\n    action_result := 'updated';\n  ELSE\n    -- Check for conflicts\n    SELECT COUNT(*) INTO conflict_count\n    FROM public.excel_import_mappings\n    WHERE excel_text = p_excel_text \n      AND mapping_type = 'delivery_specification'\n      AND (COALESCE(delivery_method_specification_id::text, '') != COALESCE(p_delivery_method_id::text, '') \n           OR is_collection_mapping != p_is_collection);\n    \n    had_conflict := conflict_count > 0;\n    \n    -- Insert new mapping\n    INSERT INTO public.excel_import_mappings (\n      excel_text,\n      delivery_method_specification_id,\n      address_extraction_pattern,\n      is_collection_mapping,\n      confidence_score,\n      created_by,\n      is_verified,\n      mapping_type\n    ) VALUES (\n      p_excel_text,\n      p_delivery_method_id,\n      p_address_pattern,\n      p_is_collection,\n      p_confidence_score,\n      p_created_by,\n      p_confidence_score >= 100,\n      'delivery_specification'\n    )\n    RETURNING id INTO final_mapping_id;\n    \n    action_result := 'created';\n  END IF;\n  \n  RETURN QUERY SELECT \n    final_mapping_id,\n    action_result,\n    prev_confidence,\n    new_confidence,\n    had_conflict;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "upsert_excel_mapping",
    "args": "p_excel_text text, p_production_stage_id uuid, p_stage_specification_id uuid, p_confidence_score integer, p_created_by uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.upsert_excel_mapping(p_excel_text text, p_production_stage_id uuid, p_stage_specification_id uuid DEFAULT NULL::uuid, p_confidence_score integer DEFAULT 100, p_created_by uuid DEFAULT auth.uid())\n RETURNS TABLE(mapping_id uuid, action_taken text, previous_confidence integer, new_confidence integer, conflict_detected boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  existing_mapping RECORD;\n  final_mapping_id uuid;\n  action_result text;\n  had_conflict boolean := false;\n  prev_confidence integer := 0;\n  new_confidence integer := p_confidence_score;\n  conflict_count integer;\nBEGIN\n  -- Check for existing mapping with same text and stage\n  SELECT * INTO existing_mapping\n  FROM public.excel_import_mappings\n  WHERE excel_text = p_excel_text \n    AND production_stage_id = p_production_stage_id;\n  \n  IF existing_mapping.id IS NOT NULL THEN\n    -- Update existing mapping with higher confidence\n    prev_confidence := existing_mapping.confidence_score;\n    new_confidence := GREATEST(existing_mapping.confidence_score + 10, p_confidence_score);\n    \n    UPDATE public.excel_import_mappings\n    SET \n      confidence_score = new_confidence,\n      stage_specification_id = COALESCE(p_stage_specification_id, stage_specification_id),\n      updated_at = now(),\n      is_verified = CASE \n        WHEN new_confidence >= 100 THEN true \n        ELSE is_verified \n      END\n    WHERE id = existing_mapping.id;\n    \n    final_mapping_id := existing_mapping.id;\n    action_result := 'updated';\n  ELSE\n    -- Check for conflicts (same text mapping to different stage)\n    SELECT COUNT(*) INTO conflict_count\n    FROM public.excel_import_mappings\n    WHERE excel_text = p_excel_text \n      AND production_stage_id != p_production_stage_id;\n    \n    had_conflict := conflict_count > 0;\n    \n    -- Insert new mapping with proper verification\n    INSERT INTO public.excel_import_mappings (\n      excel_text,\n      production_stage_id,\n      stage_specification_id,\n      confidence_score,\n      created_by,\n      is_verified,\n      mapping_type\n    ) VALUES (\n      p_excel_text,\n      p_production_stage_id,\n      p_stage_specification_id,\n      p_confidence_score,\n      p_created_by,\n      p_confidence_score >= 100,\n      'production_stage'\n    )\n    RETURNING id INTO final_mapping_id;\n    \n    action_result := 'created';\n  END IF;\n  \n  RETURN QUERY SELECT \n    final_mapping_id,\n    action_result,\n    prev_confidence,\n    new_confidence,\n    had_conflict;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "upsert_paper_specification_mapping",
    "args": "p_excel_text text, p_paper_type_id uuid, p_paper_weight_id uuid, p_confidence_score integer, p_created_by uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.upsert_paper_specification_mapping(p_excel_text text, p_paper_type_id uuid, p_paper_weight_id uuid, p_confidence_score integer DEFAULT 100, p_created_by uuid DEFAULT auth.uid())\n RETURNS TABLE(mapping_id uuid, action_taken text, previous_confidence integer, new_confidence integer, conflict_detected boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  existing_mapping RECORD;\n  final_mapping_id uuid;\n  action_result text;\n  had_conflict boolean := false;\n  prev_confidence integer := 0;\n  new_confidence integer := p_confidence_score;\n  conflict_count integer;\nBEGIN\n  -- Check for existing mapping with same text and paper specs\n  SELECT * INTO existing_mapping\n  FROM public.excel_import_mappings\n  WHERE excel_text = p_excel_text \n    AND paper_type_specification_id = p_paper_type_id\n    AND paper_weight_specification_id = p_paper_weight_id\n    AND mapping_type = 'paper_specification';\n  \n  IF existing_mapping.id IS NOT NULL THEN\n    -- Update existing mapping\n    prev_confidence := existing_mapping.confidence_score;\n    new_confidence := GREATEST(existing_mapping.confidence_score + 10, p_confidence_score);\n    \n    UPDATE public.excel_import_mappings\n    SET \n      confidence_score = new_confidence,\n      updated_at = now(),\n      is_verified = CASE \n        WHEN new_confidence >= 100 THEN true \n        ELSE is_verified \n      END\n    WHERE id = existing_mapping.id;\n    \n    final_mapping_id := existing_mapping.id;\n    action_result := 'updated';\n  ELSE\n    -- Check for conflicts\n    SELECT COUNT(*) INTO conflict_count\n    FROM public.excel_import_mappings\n    WHERE excel_text = p_excel_text \n      AND mapping_type = 'paper_specification'\n      AND (paper_type_specification_id != p_paper_type_id OR paper_weight_specification_id != p_paper_weight_id);\n    \n    had_conflict := conflict_count > 0;\n    \n    -- Insert new mapping\n    INSERT INTO public.excel_import_mappings (\n      excel_text,\n      paper_type_specification_id,\n      paper_weight_specification_id,\n      confidence_score,\n      created_by,\n      is_verified,\n      mapping_type\n    ) VALUES (\n      p_excel_text,\n      p_paper_type_id,\n      p_paper_weight_id,\n      p_confidence_score,\n      p_created_by,\n      p_confidence_score >= 100,\n      'paper_specification'\n    )\n    RETURNING id INTO final_mapping_id;\n    \n    action_result := 'created';\n  END IF;\n  \n  RETURN QUERY SELECT \n    final_mapping_id,\n    action_result,\n    prev_confidence,\n    new_confidence,\n    had_conflict;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "upsert_print_specification_mapping",
    "args": "p_excel_text text, p_print_specification_id uuid, p_confidence_score integer, p_created_by uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.upsert_print_specification_mapping(p_excel_text text, p_print_specification_id uuid, p_confidence_score integer DEFAULT 100, p_created_by uuid DEFAULT auth.uid())\n RETURNS TABLE(mapping_id uuid, action_taken text, previous_confidence integer, new_confidence integer, conflict_detected boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  existing_mapping RECORD;\n  final_mapping_id uuid;\n  action_result text;\n  had_conflict boolean := false;\n  conflict_count integer := 0;\n  prev_confidence integer := 0;\n  new_confidence integer := p_confidence_score;\nBEGIN\n  -- Check for existing mapping with same text and specification\n  SELECT * INTO existing_mapping\n  FROM public.excel_import_mappings\n  WHERE excel_text = p_excel_text \n    AND print_specification_id = p_print_specification_id\n    AND mapping_type = 'print_specification';\n  \n  IF existing_mapping.id IS NOT NULL THEN\n    -- Update existing mapping with higher confidence\n    prev_confidence := existing_mapping.confidence_score;\n    new_confidence := GREATEST(existing_mapping.confidence_score + 10, p_confidence_score);\n    \n    UPDATE public.excel_import_mappings\n    SET \n      confidence_score = new_confidence,\n      updated_at = now(),\n      is_verified = CASE \n        WHEN new_confidence >= 150 THEN true \n        ELSE is_verified \n      END\n    WHERE id = existing_mapping.id;\n    \n    final_mapping_id := existing_mapping.id;\n    action_result := 'updated';\n  ELSE\n    -- Check for conflicts (same text mapping to different print specifications)\n    SELECT COUNT(*) INTO conflict_count\n    FROM public.excel_import_mappings\n    WHERE excel_text = p_excel_text \n      AND mapping_type = 'print_specification'\n      AND print_specification_id != p_print_specification_id;\n    \n    had_conflict := conflict_count > 0;\n    \n    -- Insert new mapping\n    INSERT INTO public.excel_import_mappings (\n      excel_text,\n      print_specification_id,\n      mapping_type,\n      confidence_score,\n      created_by,\n      is_verified\n    ) VALUES (\n      p_excel_text,\n      p_print_specification_id,\n      'print_specification',\n      p_confidence_score,\n      p_created_by,\n      p_confidence_score >= 150\n    )\n    RETURNING id INTO final_mapping_id;\n    \n    action_result := 'created';\n  END IF;\n  \n  RETURN QUERY SELECT \n    final_mapping_id,\n    action_result,\n    prev_confidence,\n    new_confidence,\n    had_conflict;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "validate_batch_integrity",
    "args": "p_batch_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.validate_batch_integrity(p_batch_id uuid)\n RETURNS TABLE(is_valid boolean, error_count integer, missing_references integer, orphaned_jobs integer, issues jsonb)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  validation_issues jsonb := '[]'::jsonb;\n  error_count integer := 0;\n  missing_refs integer := 0;\n  orphaned_count integer := 0;\nBEGIN\n  -- Check if batch exists\n  IF NOT EXISTS (SELECT 1 FROM public.batches WHERE id = p_batch_id) THEN\n    validation_issues := validation_issues || jsonb_build_object('type', 'missing_batch', 'message', 'Batch does not exist');\n    error_count := error_count + 1;\n  END IF;\n  \n  -- Check for missing batch job references\n  SELECT COUNT(*) INTO missing_refs\n  FROM public.production_jobs pj\n  WHERE pj.batch_ready = true\n    AND NOT EXISTS (\n      SELECT 1 FROM public.batch_job_references bjr \n      WHERE bjr.production_job_id = pj.id\n    );\n    \n  IF missing_refs > 0 THEN\n    validation_issues := validation_issues || jsonb_build_object(\n      'type', 'missing_references', \n      'count', missing_refs,\n      'message', format('%s production jobs are batch ready but have no references', missing_refs)\n    );\n    error_count := error_count + 1;\n  END IF;\n  \n  -- Check for orphaned batch references\n  SELECT COUNT(*) INTO orphaned_count\n  FROM public.batch_job_references bjr\n  WHERE bjr.batch_id = p_batch_id\n    AND NOT EXISTS (\n      SELECT 1 FROM public.production_jobs pj \n      WHERE pj.id = bjr.production_job_id\n    );\n    \n  IF orphaned_count > 0 THEN\n    validation_issues := validation_issues || jsonb_build_object(\n      'type', 'orphaned_references', \n      'count', orphaned_count,\n      'message', format('%s batch references point to non-existent production jobs', orphaned_count)\n    );\n    error_count := error_count + 1;\n  END IF;\n  \n  RETURN QUERY SELECT \n    error_count = 0,\n    error_count,\n    missing_refs,\n    orphaned_count,\n    validation_issues;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "validate_batch_simple",
    "args": "p_batch_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.validate_batch_simple(p_batch_id uuid)\n RETURNS TABLE(is_valid boolean, reference_count integer, missing_jobs integer, message text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  batch_exists boolean;\n  ref_count integer;\n  missing_count integer;\n  validation_message text;\nBEGIN\n  -- Check if batch exists\n  SELECT EXISTS(SELECT 1 FROM public.batches WHERE id = p_batch_id) INTO batch_exists;\n  \n  IF NOT batch_exists THEN\n    RETURN QUERY SELECT false, 0, 0, 'Batch does not exist';\n    RETURN;\n  END IF;\n  \n  -- Count batch job references\n  SELECT COUNT(*) INTO ref_count\n  FROM public.batch_job_references\n  WHERE batch_id = p_batch_id;\n  \n  -- Count missing production jobs (orphaned references)\n  SELECT COUNT(*) INTO missing_count\n  FROM public.batch_job_references bjr\n  LEFT JOIN public.production_jobs pj ON pj.id = bjr.production_job_id\n  WHERE bjr.batch_id = p_batch_id AND pj.id IS NULL;\n  \n  -- Determine validation result\n  IF ref_count = 0 THEN\n    validation_message := 'No batch references found';\n    RETURN QUERY SELECT false, ref_count, missing_count, validation_message;\n  ELSIF missing_count > 0 THEN\n    validation_message := format('%s references found, %s missing production jobs', ref_count, missing_count);\n    RETURN QUERY SELECT false, ref_count, missing_count, validation_message;\n  ELSE\n    validation_message := format('%s valid references found', ref_count);\n    RETURN QUERY SELECT true, ref_count, missing_count, validation_message;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "validate_business_hours",
    "args": "check_time timestamp with time zone",
    "language": "sql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.validate_business_hours(check_time timestamp with time zone)\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n  SELECT \n    EXTRACT(hour FROM check_time AT TIME ZONE 'Africa/Johannesburg') >= 8 \n    AND \n    (EXTRACT(hour FROM check_time AT TIME ZONE 'Africa/Johannesburg') < 17 \n     OR (EXTRACT(hour FROM check_time AT TIME ZONE 'Africa/Johannesburg') = 17 \n         AND EXTRACT(minute FROM check_time AT TIME ZONE 'Africa/Johannesburg') <= 30))\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "validate_not_in_past",
    "args": "check_time timestamp with time zone",
    "language": "sql",
    "security_definer": false,
    "volatility": "s",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.validate_not_in_past(check_time timestamp with time zone)\n RETURNS boolean\n LANGUAGE sql\n STABLE\nAS $function$\n  SELECT check_time >= now()\n$function$\n"
  },
  {
    "function_schema": "public",
    "function_name": "validate_working_day",
    "args": "check_time timestamp with time zone",
    "language": "sql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION public.validate_working_day(check_time timestamp with time zone)\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n  SELECT EXTRACT(dow FROM check_time AT TIME ZONE 'Africa/Johannesburg') BETWEEN 1 AND 5\n$function$\n"
  },
  {
    "function_schema": "realtime",
    "function_name": "apply_rls",
    "args": "wal jsonb, max_record_bytes integer",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))\n RETURNS SETOF realtime.wal_rls\n LANGUAGE plpgsql\nAS $function$\ndeclare\n-- Regclass of the table e.g. public.notes\nentity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n-- I, U, D, T: insert, update ...\naction realtime.action = (\n    case wal ->> 'action'\n        when 'I' then 'INSERT'\n        when 'U' then 'UPDATE'\n        when 'D' then 'DELETE'\n        else 'ERROR'\n    end\n);\n\n-- Is row level security enabled for the table\nis_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\nsubscriptions realtime.subscription[] = array_agg(subs)\n    from\n        realtime.subscription subs\n    where\n        subs.entity = entity_;\n\n-- Subscription vars\nroles regrole[] = array_agg(distinct us.claims_role::text)\n    from\n        unnest(subscriptions) us;\n\nworking_role regrole;\nclaimed_role regrole;\nclaims jsonb;\n\nsubscription_id uuid;\nsubscription_has_access bool;\nvisible_to_subscription_ids uuid[] = '{}';\n\n-- structured info for wal's columns\ncolumns realtime.wal_column[];\n-- previous identity values for update/delete\nold_columns realtime.wal_column[];\n\nerror_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;\n\n-- Primary jsonb output for record\noutput jsonb;\n\nbegin\nperform set_config('role', null, true);\n\ncolumns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'columns') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nold_columns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'identity') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nfor working_role in select * from unnest(roles) loop\n\n    -- Update `is_selectable` for columns and old_columns\n    columns =\n        array_agg(\n            (\n                c.name,\n                c.type_name,\n                c.type_oid,\n                c.value,\n                c.is_pkey,\n                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n            )::realtime.wal_column\n        )\n        from\n            unnest(columns) c;\n\n    old_columns =\n            array_agg(\n                (\n                    c.name,\n                    c.type_name,\n                    c.type_oid,\n                    c.value,\n                    c.is_pkey,\n                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                )::realtime.wal_column\n            )\n            from\n                unnest(old_columns) c;\n\n    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            -- subscriptions is already filtered by entity\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role "
  },
  {
    "function_schema": "realtime",
    "function_name": "broadcast_changes",
    "args": "topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    -- Declare a variable to hold the JSONB representation of the row\n    row_data jsonb := '{}'::jsonb;\nBEGIN\n    IF level = 'STATEMENT' THEN\n        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';\n    END IF;\n    -- Check the operation type and handle accordingly\n    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN\n        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);\n        PERFORM realtime.send (row_data, event_name, topic_name);\n    ELSE\n        RAISE EXCEPTION 'Unexpected operation type: %', operation;\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;\nEND;\n\n$function$\n"
  },
  {
    "function_schema": "realtime",
    "function_name": "build_prepared_statement_sql",
    "args": "prepared_statement_name text, entity regclass, columns realtime.wal_column[]",
    "language": "sql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])\n RETURNS text\n LANGUAGE sql\nAS $function$\n      /*\n      Builds a sql string that, if executed, creates a prepared statement to\n      tests retrive a row from *entity* by its primary key columns.\n      Example\n          select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])\n      */\n          select\n      'prepare ' || prepared_statement_name || ' as\n          select\n              exists(\n                  select\n                      1\n                  from\n                      ' || entity || '\n                  where\n                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '\n              )'\n          from\n              unnest(columns) pkc\n          where\n              pkc.is_pkey\n          group by\n              entity\n      $function$\n"
  },
  {
    "function_schema": "realtime",
    "function_name": "cast",
    "args": "val text, type_ regtype",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION realtime.\"cast\"(val text, type_ regtype)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n    declare\n      res jsonb;\n    begin\n      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;\n      return res;\n    end\n    $function$\n"
  },
  {
    "function_schema": "realtime",
    "function_name": "check_equality_op",
    "args": "op realtime.equality_op, type_ regtype, val_1 text, val_2 text",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)\n RETURNS boolean\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n      /*\n      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness\n      */\n      declare\n          op_symbol text = (\n              case\n                  when op = 'eq' then '='\n                  when op = 'neq' then '!='\n                  when op = 'lt' then '<'\n                  when op = 'lte' then '<='\n                  when op = 'gt' then '>'\n                  when op = 'gte' then '>='\n                  when op = 'in' then '= any'\n                  else 'UNKNOWN OP'\n              end\n          );\n          res boolean;\n      begin\n          execute format(\n              'select %L::'|| type_::text || ' ' || op_symbol\n              || ' ( %L::'\n              || (\n                  case\n                      when op = 'in' then type_::text || '[]'\n                      else type_::text end\n              )\n              || ')', val_1, val_2) into res;\n          return res;\n      end;\n      $function$\n"
  },
  {
    "function_schema": "realtime",
    "function_name": "is_visible_through_filters",
    "args": "columns realtime.wal_column[], filters realtime.user_defined_filter[]",
    "language": "sql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    Should the record be visible (true) or filtered out (false) after *filters* are applied\n    */\n        select\n            -- Default to allowed when no filters present\n            $2 is null -- no filters. this should not happen because subscriptions has a default\n            or array_length($2, 1) is null -- array length of an empty array is null\n            or bool_and(\n                coalesce(\n                    realtime.check_equality_op(\n                        op:=f.op,\n                        type_:=coalesce(\n                            col.type_oid::regtype, -- null when wal2json version <= 2.4\n                            col.type_name::regtype\n                        ),\n                        -- cast jsonb to text\n                        val_1:=col.value #>> '{}',\n                        val_2:=f.value\n                    ),\n                    false -- if null, filter does not match\n                )\n            )\n        from\n            unnest(filters) f\n            join unnest(columns) col\n                on f.column_name = col.name;\n    $function$\n"
  },
  {
    "function_schema": "realtime",
    "function_name": "list_changes",
    "args": "publication name, slot_name name, max_changes integer, max_record_bytes integer",
    "language": "sql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)\n RETURNS SETOF realtime.wal_rls\n LANGUAGE sql\n SET log_min_messages TO 'fatal'\nAS $function$\n      with pub as (\n        select\n          concat_ws(\n            ',',\n            case when bool_or(pubinsert) then 'insert' else null end,\n            case when bool_or(pubupdate) then 'update' else null end,\n            case when bool_or(pubdelete) then 'delete' else null end\n          ) as w2j_actions,\n          coalesce(\n            string_agg(\n              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),\n              ','\n            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),\n            ''\n          ) w2j_add_tables\n        from\n          pg_publication pp\n          left join pg_publication_tables ppt\n            on pp.pubname = ppt.pubname\n        where\n          pp.pubname = publication\n        group by\n          pp.pubname\n        limit 1\n      ),\n      w2j as (\n        select\n          x.*, pub.w2j_add_tables\n        from\n          pub,\n          pg_logical_slot_get_changes(\n            slot_name, null, max_changes,\n            'include-pk', 'true',\n            'include-transaction', 'false',\n            'include-timestamp', 'true',\n            'include-type-oids', 'true',\n            'format-version', '2',\n            'actions', pub.w2j_actions,\n            'add-tables', pub.w2j_add_tables\n          ) x\n      )\n      select\n        xyz.wal,\n        xyz.is_rls_enabled,\n        xyz.subscription_ids,\n        xyz.errors\n      from\n        w2j,\n        realtime.apply_rls(\n          wal := w2j.data::jsonb,\n          max_record_bytes := max_record_bytes\n        ) xyz(wal, is_rls_enabled, subscription_ids, errors)\n      where\n        w2j.w2j_add_tables <> ''\n        and xyz.subscription_ids[1] is not null\n    $function$\n"
  },
  {
    "function_schema": "realtime",
    "function_name": "quote_wal2json",
    "args": "entity regclass",
    "language": "sql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\n      select\n        (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n        )\n        || '.'\n        || (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n          )\n      from\n        pg_class pc\n        join pg_namespace nsp\n          on pc.relnamespace = nsp.oid\n      where\n        pc.oid = entity\n    $function$\n"
  },
  {
    "function_schema": "realtime",
    "function_name": "send",
    "args": "payload jsonb, event text, topic text, private boolean",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  BEGIN\n    -- Set the topic configuration\n    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);\n\n    -- Attempt to insert the message\n    INSERT INTO realtime.messages (payload, event, topic, private, extension)\n    VALUES (payload, event, topic, private, 'broadcast');\n  EXCEPTION\n    WHEN OTHERS THEN\n      -- Capture and notify the error\n      RAISE WARNING 'ErrorSendingBroadcastMessage: %', SQLERRM;\n  END;\nEND;\n$function$\n"
  },
  {
    "function_schema": "realtime",
    "function_name": "subscription_check_filters",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity\n                and pg_catalog.has_column_privilege(\n                    (new.claims ->> 'role'),\n                    format('%I.%I', c.table_schema, c.table_name)::regclass,\n                    c.column_name,\n                    'SELECT'\n                );\n        filter realtime.user_defined_filter;\n        col_type regtype;\n\n        in_val jsonb;\n    begin\n        for filter in select * from unnest(new.filters) loop\n            -- Filtered column is valid\n            if not filter.column_name = any(col_names) then\n                raise exception 'invalid column for filter %', filter.column_name;\n            end if;\n\n            -- Type is sanitized and safe for string interpolation\n            col_type = (\n                select atttypid::regtype\n                from pg_catalog.pg_attribute\n                where attrelid = new.entity\n                      and attname = filter.column_name\n            );\n            if col_type is null then\n                raise exception 'failed to lookup type for column %', filter.column_name;\n            end if;\n\n            -- Set maximum number of entries for in filter\n            if filter.op = 'in'::realtime.equality_op then\n                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);\n                if coalesce(jsonb_array_length(in_val), 0) > 100 then\n                    raise exception 'too many values for `in` filter. Maximum 100';\n                end if;\n            else\n                -- raises an exception if value is not coercable to type\n                perform realtime.cast(filter.value, col_type);\n            end if;\n\n        end loop;\n\n        -- Apply consistent order to filters so the unique constraint on\n        -- (subscription_id, entity, filters) can't be tricked by a different filter order\n        new.filters = coalesce(\n            array_agg(f order by f.column_name, f.op, f.value),\n            '{}'\n        ) from unnest(new.filters) f;\n\n        return new;\n    end;\n    $function$\n"
  },
  {
    "function_schema": "realtime",
    "function_name": "to_regrole",
    "args": "role_name text",
    "language": "sql",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)\n RETURNS regrole\n LANGUAGE sql\n IMMUTABLE\nAS $function$ select role_name::regrole $function$\n"
  },
  {
    "function_schema": "realtime",
    "function_name": "topic",
    "args": "",
    "language": "sql",
    "security_definer": false,
    "volatility": "s",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION realtime.topic()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\nselect nullif(current_setting('realtime.topic', true), '')::text;\n$function$\n"
  },
  {
    "function_schema": "storage",
    "function_name": "can_insert_object",
    "args": "bucketid text, name text, owner uuid, metadata jsonb",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n$function$\n"
  },
  {
    "function_schema": "storage",
    "function_name": "extension",
    "args": "name text",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION storage.extension(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\n_filename text;\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\tselect _parts[array_length(_parts,1)] into _filename;\n\t-- @todo return the last part instead of 2\n\treturn reverse(split_part(reverse(_filename), '.', 1));\nEND\n$function$\n"
  },
  {
    "function_schema": "storage",
    "function_name": "filename",
    "args": "name text",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION storage.filename(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n$function$\n"
  },
  {
    "function_schema": "storage",
    "function_name": "foldername",
    "args": "name text",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION storage.foldername(name text)\n RETURNS text[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[1:array_length(_parts,1)-1];\nEND\n$function$\n"
  },
  {
    "function_schema": "storage",
    "function_name": "get_size_by_bucket",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()\n RETURNS TABLE(size bigint, bucket_id text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    return query\n        select sum((metadata->>'size')::int) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n$function$\n"
  },
  {
    "function_schema": "storage",
    "function_name": "list_multipart_uploads_with_delimiter",
    "args": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer, next_key_token text, next_upload_token text",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)\n RETURNS TABLE(key text, id text, created_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE\n                bucket_id = $5 AND\n                key ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $4 != '''' AND $6 = '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                key COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END AND\n                CASE\n                    WHEN $6 != '''' THEN\n                        id COLLATE \"C\" > $6\n                    ELSE\n                        true\n                    END\n            ORDER BY\n                key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;\nEND;\n$function$\n"
  },
  {
    "function_schema": "storage",
    "function_name": "list_objects_with_delimiter",
    "args": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer, start_after text, next_token text",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)\n RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(name COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))\n                    ELSE\n                        name\n                END AS name, id, metadata, updated_at\n            FROM\n                storage.objects\n            WHERE\n                bucket_id = $5 AND\n                name ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $6 != '''' THEN\n                    name COLLATE \"C\" > $6\n                ELSE true END\n                AND CASE\n                    WHEN $4 != '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                name COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END\n            ORDER BY\n                name COLLATE \"C\" ASC) as e order by name COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;\nEND;\n$function$\n"
  },
  {
    "function_schema": "storage",
    "function_name": "operation",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "s",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION storage.operation()\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n$function$\n"
  },
  {
    "function_schema": "storage",
    "function_name": "search",
    "args": "prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "s",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n  v_order_by text;\n  v_sort_order text;\nbegin\n  case\n    when sortcolumn = 'name' then\n      v_order_by = 'name';\n    when sortcolumn = 'updated_at' then\n      v_order_by = 'updated_at';\n    when sortcolumn = 'created_at' then\n      v_order_by = 'created_at';\n    when sortcolumn = 'last_accessed_at' then\n      v_order_by = 'last_accessed_at';\n    else\n      v_order_by = 'name';\n  end case;\n\n  case\n    when sortorder = 'asc' then\n      v_sort_order = 'asc';\n    when sortorder = 'desc' then\n      v_sort_order = 'desc';\n    else\n      v_sort_order = 'asc';\n  end case;\n\n  v_order_by = v_order_by || ' ' || v_sort_order;\n\n  return query execute\n    'with folders as (\n       select path_tokens[$1] as folder\n       from storage.objects\n         where objects.name ilike $2 || $3 || ''%''\n           and bucket_id = $4\n           and array_length(objects.path_tokens, 1) <> $1\n       group by folder\n       order by folder ' || v_sort_order || '\n     )\n     (select folder as \"name\",\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[$1] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where objects.name ilike $2 || $3 || ''%''\n       and bucket_id = $4\n       and array_length(objects.path_tokens, 1) = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
  },
  {
    "function_schema": "storage",
    "function_name": "update_updated_at_column",
    "args": "",
    "language": "plpgsql",
    "security_definer": false,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION storage.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n$function$\n"
  },
  {
    "function_schema": "vault",
    "function_name": "_crypto_aead_det_decrypt",
    "args": "message bytea, additional bytea, key_id bigint, context bytea, nonce bytea",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_decrypt_by_id$function$\n"
  },
  {
    "function_schema": "vault",
    "function_name": "_crypto_aead_det_encrypt",
    "args": "message bytea, additional bytea, key_id bigint, context bytea, nonce bytea",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_encrypt_by_id$function$\n"
  },
  {
    "function_schema": "vault",
    "function_name": "_crypto_aead_det_noncegen",
    "args": "",
    "language": "c",
    "security_definer": false,
    "volatility": "i",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_noncegen()\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_noncegen$function$\n"
  },
  {
    "function_schema": "vault",
    "function_name": "create_secret",
    "args": "new_secret text, new_name text, new_description text, new_key_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  rec record;\nBEGIN\n  INSERT INTO vault.secrets (secret, name, description)\n  VALUES (\n    new_secret,\n    new_name,\n    new_description\n  )\n  RETURNING * INTO rec;\n  UPDATE vault.secrets s\n  SET secret = encode(vault._crypto_aead_det_encrypt(\n    message := convert_to(rec.secret, 'utf8'),\n    additional := convert_to(s.id::text, 'utf8'),\n    key_id := 0,\n    context := 'pgsodium'::bytea,\n    nonce := rec.nonce\n  ), 'base64')\n  WHERE id = rec.id;\n  RETURN rec.id;\nEND\n$function$\n"
  },
  {
    "function_schema": "vault",
    "function_name": "update_secret",
    "args": "secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid",
    "language": "plpgsql",
    "security_definer": true,
    "volatility": "v",
    "definition_excerpt": "CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  decrypted_secret text := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE id = secret_id);\nBEGIN\n  UPDATE vault.secrets s\n  SET\n    secret = CASE WHEN new_secret IS NULL THEN s.secret\n                  ELSE encode(vault._crypto_aead_det_encrypt(\n                    message := convert_to(new_secret, 'utf8'),\n                    additional := convert_to(s.id::text, 'utf8'),\n                    key_id := 0,\n                    context := 'pgsodium'::bytea,\n                    nonce := s.nonce\n                  ), 'base64') END,\n    name = coalesce(new_name, s.name),\n    description = coalesce(new_description, s.description),\n    updated_at = now()\n  WHERE s.id = secret_id;\nEND\n$function$\n"
  }
]